#!/usr/bin/env python3
import tkinter as tk
import tkinter.font
import tkinter.ttk as ttk
from tkinter import colorchooser

from matplotlib.collections import PatchCollection
from matplotlib.backends.backend_tkagg import (
    FigureCanvasTkAgg, NavigationToolbar2Tk)
# Implement the default Matplotlib key bindings.
from matplotlib.backend_bases import key_press_handler
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
from glob import glob
import numpy as np
from sys import argv, excepthook
from time import time
from os.path import isfile
from os import nice
from signal import signal,SIGINT
from struct import unpack
from numpy.lib.recfunctions import repack_fields
from scipy.spatial.distance import cdist
from scipy.integrate import simps

nice(5)

def read_binary(filename,
         return_header=True,
         return_data=True,
         fmt_header= '2i'+    # ntot, nnopt (2*4=8)
                     '5d'+    # hco, hfloor, sep0, tf, dtout (8*5=40)
                     '2i'+    # nout, nit (2*4=8)
                     'd'+     # t (8)
                     'i'+     # nav (4)
                     '3d'+    # alpha, beta, tjumpahead (3*8=24)
                     '2i'+    # ngr, nrelax (4*2=8)
                     '3d'+    # trelax, dt, omega2 (3*8=24)
                     'i'+     # ncooling (4)
                     'd'+     # erad (8)
                     'i'+     # ndisplace (4)
                     '3d',    # displacex, displacey, displacez (4*8=24),
         fmt_dataline= 'f8,'+ # x
                       'f8,'+ # y
                       'f8,'+ # z
                       'f8,'+ # am
                       'f8,'+ # hp
                       'f8,'+ # rho
                       'f8,'+ # vx
                       'f8,'+ # vy
                       'f8,'+ # vz
                       'f8,'+ # vxdot
                       'f8,'+ # vydot
                       'f8,'+ # vzdot
                       'f8,'+ # u
                       'f8,'+ # udot
                       'f8,'+ # grpot
                       'f8,'+ # meanmolecular
                       'f4,'+ # cc
                       'f8',  # divv
         fmt_extra='',
         size_header=164,
         size_dataline=156,
         size_extra=0,
         lines=0):
    

    if fmt_extra != '': fmt_extra = ','+fmt_extra
    dsize = size_dataline+size_extra+8
    
    with open(filename,'rb') as f:
        header = np.asarray(unpack('<i'+fmt_header+'d', f.read(4+size_header+8)))[1:-1]
        if lines == 0: lines = int(header[0])

        if int(header[19]) != 0: #if ncooling =/= 0
            fmt_dataline += ',f8,f8'
            dsize+=16

        if return_data:
            try:
                #data = np.ndarray(shape=(1,lines),
                #                  dtype=np.dtype(fmt_dataline+fmt_extra+',f8'),
                #                  buffer=f.read(lines*dsize))[0].astype(dsize*'f8,').view(dtype='f8').reshape(lines,dsize)[:,:-1]
            
                dtype = fmt_dataline+fmt_extra+',f8'
                data = np.zeros((lines,dtype.count(',')+1))
                
                data[:] = np.ndarray(shape=(1,lines),
                                     dtype=np.dtype(dtype),
                                     buffer=f.read(lines*dsize))[0].tolist()[:]
                data=data[:,:-1]
                
            except:
                data = None
                header = None

            if return_header: return data,header
            else: return data
        else:
            if return_header: return header


def _read_mesafile(filename, data_rows=0, only='all'):
    # Taken from mesa_read.py written by Kenny X. Van
    ''' private routine that is not directly called by the user'''
    f = open(filename, 'r')
    vv = []
    v = []
    lines = []
    line = ''
    for i in range(0, 6):
        line = f.readline()
        lines.extend([line])

    hval = lines[2].split()
    hlist = lines[1].split()
    header_attr = {}
    for a, b in zip(hlist, hval):
        header_attr[a] = float(b)
    if only == 'header_attr':
        return header_attr

    cols = {}
    colnum = lines[4].split()
    colname = lines[5].split()
    for a, b in zip(colname, colnum):
        cols[a] = int(b)

    data = []

    for i in range(data_rows):
        line = f.readline()
        v = line.split()
        try:
            vv = np.array(v, dtype='float64')
        except ValueError:
            for item in v:
                if item.__contains__('.') and not item.__contains__('E'):
                    v[v.index(item)] = '0'
        data.append(vv)

    #print ' \n'
    f.close()
    a = np.array(data)
    data = []
    return header_attr, cols, a
            
def read_mesa(filename):
    header_attr = _read_mesafile(filename, only='header_attr')
    try:
        num_zones = int(header_attr['num_zones'])
    except KeyError:
        return None,None,None

    header_attr, cols, data = _read_mesafile(filename, data_rows=num_zones, only='all')
    return header_attr,cols,data


def rgb2tk(rgb):
    """translates an rgb tuple of int to a tkinter friendly color code
    """
    return "#%02x%02x%02x" % rgb

class CustomToolbar(NavigationToolbar2Tk):
    def __init__(self,canvas_,parent_,dpi):
        self.toolitems = (
            (u'Home', u'', u'home', u'home'),
            (u'Pan', u'', u'move', u'pan'),
            (u'Zoom', u'', u'zoom_to_rect', u'zoom'),
            (u'Subplots', u'', u'subplots', u'configure_subplots'),
            (u'Save', u'', u'filesave', u'save_figure'),
            )
        self.dpi = dpi
        self.canvas = canvas_
        self.toolbar = NavigationToolbar2Tk
        self.toolbar._old_Button = self.toolbar._Button
        self.toolbar._Button = self._new_Button
        self.toolbar.__init__(self,canvas_,parent_)
        self.toolbar.home = self.new_home
        
    def _new_Button(self, *args, **kwargs):
        b = self._old_Button(*args, **kwargs)
        # It expects dpi=100, but we have a different dpi. Because shit is
        # stupid, we have to first increase the image size then decrease it
        # using integers.
        b._ntimage = b._ntimage.zoom(self.dpi,self.dpi)
        b._ntimage = b._ntimage.subsample(100,100)
        self.height = b._ntimage.height()
        b.config(height=self.height,image=b._ntimage)
        return b
        
    def new_home(self,*args):
        # The original "home" function looks like this:
        #"""Restore the original view."""
        #self.toolbar._nav_stack.home()
        #self.toolbar.set_history_buttons(self.toolbar)
        #self.toolbar._update_view(self.toolbar)

        self.toolbar.home(self.toolbar)
        
        # We want to do everything the original home function does,
        # but this time correctly set the plotting limits.
        
        # ax[0] is the axis we can see. Not sure what ax[1] is.
        ax = self.canvas.figure.axes[0]
        margin = ax.margins()
        xmin = np.inf
        xmax = -np.inf
        ymin = np.inf
        ymax = -np.inf
        
        # This will work only for scatter plots. Revise in the future if needed.
        for child in ax.get_children():
            if type(child).__name__ == "PathCollection":
                xy = child.get_offsets()
                xmin = min(xmin,np.nanmin(xy[:,0]))
                xmax = max(xmax,np.nanmax(xy[:,0]))
                ymin = min(ymin,np.nanmin(xy[:,1]))
                ymax = max(ymax,np.nanmax(xy[:,1]))

        dx = xmax-xmin
        dy = ymax-ymin
        ax.set_xlim(xmin - dx*margin[0], xmax + dx*margin[0])
        ax.set_ylim(ymin - dy*margin[1], ymax + dy*margin[1])
        self.canvas.draw()
        
class main():

    ### Helpers
    ###########
    
    def Entry(self,*args,**kwargs):
        if 'font' not in kwargs.keys(): kwargs['font'] = tk.font.nametofont("TkDefaultFont")
        return tk.Entry(*args,**kwargs)

    def Combobox(self,*args,**kwargs):
        if 'font' not in kwargs.keys(): kwargs['font'] = tk.font.nametofont("TkDefaultFont")
        return ttk.Combobox(*args,**kwargs)

    
    
    def __init__(self,root):

        self.root = root

        # Init kernels for SPH code
        self.ntab = 100000 # ntab = 100000 from StarSmasher
        self.ctab = float(self.ntab - 1)/4.
        self.init_kernels() # Cubic spline only for now
        
        self.data = None
        self.header = None

        # Assume an SPH data file by default
        self.sph_variables = [ "x",
                               "y",
                               "z",
                               "m",
                               "h",
                               "rho",
                               "vx",
                               "vy",
                               "vz",
                               "vxdot",
                               "vydot",
                               "vzdot",
                               "u",
                               "udot",
                               "grpot",
                               "meanmolecular",
                               "cc",
                               "divv",
                               "----",
                               "r",
                               "r from particle 0",
                               "mencl",
                               "E",
                              ]
        self.sph_color_variables = [ "",
                                 "column density",
                               ]
        self.cmap_names = [ 'nipy_spectral','viridis', 'plasma', 'inferno', 'magma', 'cividis',
                            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds','YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu','GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn',
                            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink','spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia','hot', 'afmhot', 'gist_heat', 'copper',
                            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu','RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic',
                            'twilight', 'twilight_shifted', 'hsv',
                            'Pastel1', 'Pastel2', 'Paired', 'Accent','Dark2', 'Set1', 'Set2', 'Set3','tab10', 'tab20', 'tab20b', 'tab20c',
                            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern','gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg','gist_rainbow', 'rainbow', 'jet', 'gist_ncar'
                          ]

        # There are some markers from matplotlib that we should not support
        # https://matplotlib.org/3.1.1/api/markers_api.html
        self.markers = [ ".",
                         ",",
                         "o",
                         "v",
                         "^",
                         "<",
                         ">",
                         "1",
                         "2",
                         "3",
                         "4",
                         "8",
                         "s",
                         "p",
                         "P",
                         "*",
                         "h",
                         "H",
                         "+",
                         "X",
                         "D",
                         "d",
                         "|",
                         "_",
                         "None",
                        ]

        self.variables = []
        self.color_variables = []

        self.sph_mode = False
        self.MESA_mode = False

        # Lists that hold plotted matplotlib objects
        self.particles = []
        self.particle_kernels = []
        self.core_particles = []
        self.core_particle_kernels = []
        self.im = None

        self.xlim = [None,None]
        self.ylim = [None,None]
        self.clim = [None,None]
        
        self.corner_message_text = tk.StringVar()
        self.corner_message_text.set("")
        self.corner_message_label = tk.Label(self.root,textvariable=self.corner_message_text)
        self.corner_message_label.place(rely=1.0,relx=1.0,x=0,y=0,anchor="se")
        
        self.right_frame = tk.Frame()
        self.left_frame = tk.Frame()
        
        self.graph_controls_frame = tk.Frame()
        self.graph_frame = tk.Frame(self.left_frame)
        self.graph_toolbar_frame = tk.Frame()
        self.axes_frame = tk.Frame(self.right_frame)
        self.files_frame = tk.Frame(self.right_frame)
        self.particle_opts_frame = tk.Frame(self.right_frame)
        self.other_opts_frame = tk.Frame(self.right_frame)
        
        # Detect proper dpi scaling
        self.default_font = tk.font.nametofont("TkDefaultFont")
        # Make sure the font is at least size 12
        fontsize_pt = 12
        if abs(self.default_font.actual()['size']) < fontsize_pt:
            self.default_font.configure(size=fontsize_pt)
        fontsize_px = self.default_font.metrics()['ascent'] + \
                      self.default_font.metrics()['descent']
        self.dpi = int(float(fontsize_px)/(fontsize_pt/72.))
        self.widget_height = fontsize_px

        # We will need to scale the text so that the dpi on the text
        # matches what we expect it to be, I think.
        
        def init_graph():
            # Setup the graph
            self.fig = Figure(figsize=(7,7),dpi=self.dpi)
            self.ax = self.fig.add_subplot(111)

            
            self.canvas = FigureCanvasTkAgg(self.fig,master=self.graph_frame)
            self.canvas.get_tk_widget().grid(row=0,column=0)
            self.canvas.draw()
            self.renderer = self.canvas.get_renderer()
            self.toolbar = CustomToolbar(self.canvas, self.graph_toolbar_frame,self.dpi)
            self.toolbar.update()
            


            # Set the initial position of the axis
            self.x0 = tk.DoubleVar()
            self.y0 = tk.DoubleVar()
            self.w = tk.DoubleVar()
            self.h = tk.DoubleVar()
            self.x0.set(0.125)
            self.y0.set(0.125)
            self.w.set(0.7)
            self.h.set(0.825)
            self.ax.set_position([self.x0.get(),self.y0.get(),self.w.get(),self.h.get()])

            # Setup horizontal and vertical axis labels
            self.hlabel_buff = tk.DoubleVar()
            self.vlabel_buff = tk.DoubleVar()
            self.hlabel_buff.set(0.1)
            self.vlabel_buff.set(0.1)
            # The labels are initially blank
            self.hlabel = self.fig.text((2.*self.x0.get()+self.w.get())/2.,self.y0.get()-self.hlabel_buff.get(),"",ha='center')
            self.vlabel = self.fig.text(self.x0.get()-self.vlabel_buff.get(),(2.*self.y0.get() + self.h.get())/2.,"",va='center',rotation='vertical')

            self.aspect = tk.StringVar()
            self.aspect.set('auto')

            

            
            
        def init_particle_controls():
            # Setup the color controls
            self.particle_color = tk.StringVar()
            self.particle_core_color = tk.StringVar()
            self.particle_size = tk.StringVar()
            self.particle_core_size = tk.StringVar()
            self.particle_marker = tk.StringVar()
            self.particle_core_marker = tk.StringVar()
            self.particle_kernel = tk.StringVar()
            self.particle_core_kernel = tk.StringVar()
            self.particle_color.set("#000000")
            self.particle_core_color.set("#000000")
            self.particle_size.set("1")
            self.particle_core_size.set("1")
            self.particle_marker.set(self.markers[0])
            self.particle_core_marker.set(self.markers[0])
            self.particle_kernel.set("0")
            self.particle_core_kernel.set("0")
            tk.Label(self.particle_opts_frame,text="Particles").grid(row=1,column=0,sticky='W')
            tk.Label(self.particle_opts_frame,text="Core particles").grid(row=2,column=0,sticky='W')
            tk.Label(self.particle_opts_frame,text="Color").grid(row=0,column=1)
            tk.Label(self.particle_opts_frame,text="Size").grid(row=0,column=2)
            tk.Label(self.particle_opts_frame,text="Marker").grid(row=0,column=3)
            #tk.Label(self.particle_opts_frame,text="Kernels").grid(row=0,column=4)
            
            self.particle_color_button = tk.Button(self.particle_opts_frame,command=self.choose_particle_color,height=1,width=2,padx=0,pady=0,bg=self.particle_color.get())
            self.particle_core_color_button = tk.Button(self.particle_opts_frame,command=self.choose_particle_core_color,height=1,width=2,padx=0,pady=0,bg=self.particle_core_color.get())
            self.particle_size_entry = self.Entry(self.particle_opts_frame,textvariable=self.particle_size,width=3)
            self.particle_core_size_entry = self.Entry(self.particle_opts_frame,textvariable=self.particle_core_size,width=3)
            self.particle_marker_combobox = self.Combobox(self.particle_opts_frame, values=self.markers,textvariable=self.particle_marker,width=5)
            self.particle_core_marker_combobox = self.Combobox(self.particle_opts_frame, values=self.markers,textvariable=self.particle_core_marker,width=5)

            self.particle_kernel_button = tk.Button(self.particle_opts_frame,text="Kernels",command=self.update_particle_kernel_button)
            self.particle_core_kernel_button = tk.Button(self.particle_opts_frame,text="Kernels",command=self.update_particle_core_kernel_button)
            
            self.particle_color_button.grid(row=1,column=1)
            self.particle_core_color_button.grid(row=2,column=1)
            self.particle_size_entry.grid(row=1,column=2)
            self.particle_core_size_entry.grid(row=2,column=2)
            self.particle_marker_combobox.grid(row=1,column=3)
            self.particle_core_marker_combobox.grid(row=2,column=3)
            self.particle_kernel_button.grid(row=1,column=4)
            self.particle_core_kernel_button.grid(row=2,column=4)

            self.particle_size.trace('w',self.update_particle_size)
            self.particle_core_size.trace('w',self.update_particle_core_size)
            self.particle_marker.trace('w',self.update_particle_marker)
            self.particle_core_marker.trace('w',self.update_particle_core_marker)

            
        

        def init_axes_options():
            # Setup the axes prompt
            self.axish_var = tk.StringVar()
            self.axisv_var = tk.StringVar()
            self.axisc_var = tk.StringVar()
            self.axish_var_prev = tk.StringVar()
            self.axisv_var_prev = tk.StringVar()
            self.axisc_var_prev = tk.StringVar()

            self.axis_menu_width = tk.IntVar()
            self.axis_menu_width.set(20)

            style = ttk.Style()
            style.map('TCombobox', fieldbackground=[('readonly','white')])
            style.map('TCombobox', selectbackground=[('readonly', 'white')])
            style.map('TCombobox', selectforeground=[('readonly', 'black')])
            style.map('TCombobox', fieldbackground=[('disabled',self.root["bg"])])
            
            self.axish_frame = tk.Frame(self.axes_frame)
            self.axisv_frame = tk.Frame(self.axes_frame)
            self.axisc_frame = tk.Frame(self.axes_frame)

            # Each of the elements in this list are a row
            self.axish_frames = []
            self.axisv_frames = []
            self.axisc_frames = []
            for i in range(0,5):
                self.axish_frames.append(tk.Frame(self.axish_frame))
                self.axisv_frames.append(tk.Frame(self.axisv_frame))
                self.axisc_frames.append(tk.Frame(self.axisc_frame))

            tk.Label(self.axish_frames[0],text="Horizontal Axis").grid(row=0,column=0)
            tk.Label(self.axisv_frames[0],text="Vertical Axis").grid(row=0,column=0)
            tk.Label(self.axisc_frames[0],text="Colorbar").grid(row=0,column=0)
            
            self.axish_combobox = self.Combobox(self.axish_frames[1], state='readonly', values=self.variables,textvariable=self.axish_var)
            self.axisv_combobox = self.Combobox(self.axisv_frames[1], state='readonly', values=self.variables,textvariable=self.axisv_var)
            self.axisc_combobox = self.Combobox(self.axisc_frames[1], state='readonly', values=self.color_variables,textvariable=self.axisc_var)

            self.axish_combobox.bind("<FocusIn>", lambda x: self.axish_combobox.selection_clear())
            self.axisv_combobox.bind("<FocusIn>", lambda x: self.axisv_combobox.selection_clear())
            self.axisc_combobox.bind("<FocusIn>", lambda x: self.axisc_combobox.selection_clear())

            self.axish_combobox.grid(row=0,column=0)
            self.axisv_combobox.grid(row=0,column=0)
            self.axisc_combobox.grid(row=0,column=0)



            self.axish_islog = tk.IntVar()
            self.axisv_islog = tk.IntVar()
            self.axisc_islog = tk.IntVar()
            self.axish_is10 = tk.IntVar()
            self.axisv_is10 = tk.IntVar()
            self.axisc_is10 = tk.IntVar()
            self.axish_isadaptive = tk.IntVar()
            self.axisv_isadaptive = tk.IntVar()
            self.axisc_isadaptive = tk.IntVar()
            self.axish_islog.set(0)
            self.axisv_islog.set(0)
            self.axisc_islog.set(0)
            self.axish_is10.set(0)
            self.axisv_is10.set(0)
            self.axisc_is10.set(0)
            self.axish_isadaptive.set(0)
            self.axisv_isadaptive.set(0)
            self.axisc_isadaptive.set(0)
            

            axis_buttons_frame = tk.Frame(self.axish_frames[2])
            log10_frame = tk.Frame(axis_buttons_frame)
            limits_frame = tk.Frame(axis_buttons_frame)
            self.axish_log_button = tk.Button(log10_frame,text="log",command=self.update_axish_log_button,relief='raised',state='normal')
            self.axish_10_button = tk.Button(log10_frame,text="10^",command=self.update_axish_10_button,relief='raised',state='normal')
            self.axish_log_button.grid(row=0,column=0)
            self.axish_10_button.grid(row=0,column=1)
            log10_frame.grid(row=0,column=0)

            tk.Label(limits_frame,text="Limits:").grid(row=0,column=0)
            self.axish_adaptive_button = tk.Button(limits_frame,text="Adaptive",command=self.update_axish_adaptive_button,relief='raised',state='normal')
            self.axish_save_limits_button = tk.Button(limits_frame,text="Save",command=self.save_axish_limits,relief='raised',state='normal')
            self.axish_adaptive_button.grid(row=0,column=1)
            self.axish_save_limits_button.grid(row=0,column=2)
            limits_frame.grid(row=1,column=0)
            axis_buttons_frame.grid(row=0,column=0)

            
            
            axis_buttons_frame = tk.Frame(self.axisv_frames[2])
            log10_frame = tk.Frame(axis_buttons_frame)
            limits_frame = tk.Frame(axis_buttons_frame)
            self.axisv_log_button = tk.Button(log10_frame,text="log",command=self.update_axisv_log_button,relief='raised',state='normal')
            self.axisv_10_button = tk.Button(log10_frame,text="10^",command=self.update_axisv_10_button,relief='raised',state='normal')
            self.axisv_log_button.grid(row=0,column=0)
            self.axisv_10_button.grid(row=0,column=1)
            log10_frame.grid(row=0,column=0)

            tk.Label(limits_frame,text="Limits:").grid(row=0,column=0)
            self.axisv_adaptive_button = tk.Button(limits_frame,text="Adaptive",command=self.update_axisv_adaptive_button,relief='raised',state='normal')
            self.axisv_save_limits_button = tk.Button(limits_frame,text="Save",command=self.save_axisv_limits,relief='raised',state='normal')
            self.axisv_adaptive_button.grid(row=0,column=1)
            self.axisv_save_limits_button.grid(row=0,column=2)
            limits_frame.grid(row=1,column=0)
            axis_buttons_frame.grid(row=0,column=0)

            
            
            axis_buttons_frame = tk.Frame(self.axisc_frames[2])
            log10_frame = tk.Frame(axis_buttons_frame)
            limits_frame = tk.Frame(axis_buttons_frame)
            self.axisc_log_button = tk.Button(log10_frame,text="log",command=self.update_axisc_log_button,relief='raised',state='normal')
            self.axisc_10_button = tk.Button(log10_frame,text="10^",command=self.update_axisc_10_button,relief='raised',state='normal')
            self.axisc_log_button.grid(row=0,column=0)
            self.axisc_10_button.grid(row=0,column=1)
            log10_frame.grid(row=0,column=0)

            tk.Label(limits_frame,text="Limits:").grid(row=0,column=0)
            self.axisc_adaptive_button = tk.Button(limits_frame,text="Adaptive",command=self.update_axisc_adaptive_button,relief='raised',state='normal')
            self.axisc_save_limits_button = tk.Button(limits_frame,text="Save",command=self.save_axisc_limits,relief='raised',state='normal')
            self.axisc_adaptive_button.grid(row=0,column=1)
            self.axisc_save_limits_button.grid(row=0,column=2)
            limits_frame.grid(row=1,column=0)
            axis_buttons_frame.grid(row=0,column=0)

            

            # Divide by 10 initially because full resolution takes a long time to compute
            #fig_pix = np.asarray(self.fig.get_size_inches() * self.fig.dpi / 10.,dtype=int) # figure size in pixels
            # 20 doesn't take too long to compute
            fig_pix = np.asarray([20,20],dtype=int)
        
            #smallframers = tk.Frame(self.axes_frame)
            resolution_frame = tk.Frame(self.axisc_frames[3])
            self.resolution_scale_x = tk.IntVar()
            self.resolution_scale_y = tk.IntVar()
            self.resolution_scale_z = tk.IntVar()
            self.resolution_scale_x.set(fig_pix[0])
            self.resolution_scale_y.set(fig_pix[1])
            self.resolution_scale_z.set(min(fig_pix))

            smallerframers = tk.Frame(resolution_frame)

            tk.Label(smallerframers,text="Resolution (px)").grid(row=0,column=0)
            self.resolution_draw_button = tk.Button(smallerframers,text="Draw",command=self.draw_plot,width=5,height=1,padx=0,pady=0)
            self.resolution_draw_button.grid(row=0,column=1)

            smallerframers.grid(row=0,column=0,columnspan=6)

            self.resolution_scale_x_entry = self.Entry(resolution_frame,textvariable=self.resolution_scale_x,width=4)
            self.resolution_scale_y_entry = self.Entry(resolution_frame,textvariable=self.resolution_scale_y,width=4)
            self.resolution_scale_z_entry = self.Entry(resolution_frame,textvariable=self.resolution_scale_z,width=4)
            self.resolution_scale_x_entry.grid(row=1,column=0)
            tk.Label(resolution_frame,text="x").grid(row=1,column=1)
            self.resolution_scale_y_entry.grid(row=1,column=2)
            tk.Label(resolution_frame,text="y").grid(row=1,column=3)
            self.resolution_scale_z_entry.grid(row=1,column=4)
            tk.Label(resolution_frame,text="z").grid(row=1,column=5)

            self.cmap_idx = tk.StringVar()
            self.cmap_idx.set("0")
            self.cmap = tk.StringVar()
            self.cmap.set(self.cmap_names[int(self.cmap_idx.get())])
            self.cmap_idx.trace('w',self.update_cmap)

            cmap_frame = tk.Frame(self.axisc_frames[4])
            
            tk.Label(cmap_frame,text="cmap").grid(row=0,column=0)
            self.cmap_entry = self.Entry(cmap_frame,textvariable=self.cmap_idx,width=2)
            self.cmap_entry.grid(row=0,column=2)

            self.cmap_next_button = tk.Button(cmap_frame,text=">",command=self.next_cmap,height=1,width=1,padx=0,pady=0)
            self.cmap_previous_button = tk.Button(cmap_frame,text="<",command=self.previous_cmap,height=1,width=1,padx=0,pady=0)
            self.cmap_next_button.grid(row=0,column=3)
            self.cmap_previous_button.grid(row=0,column=1)
            

            # Grid everything
            for i in range(0,len(self.axish_frames)):
                self.axish_frames[i].grid(row=i,column=0)
            for i in range(0,len(self.axisv_frames)):
                self.axisv_frames[i].grid(row=i,column=0)
            for i in range(0,len(self.axisc_frames)):
                self.axisc_frames[i].grid(row=i,column=0)

            cmap_frame.grid(row=0,column=2)
            resolution_frame.grid(row=0,column=0)
            self.axish_frame.grid(row=0,column=0,sticky='N')
            self.axisv_frame.grid(row=0,column=1,sticky='N')
            self.axisc_frame.grid(row=0,column=2,sticky='N')


        def init_files_prompt():
            # Setup the files prompt
            self.files_var = tk.StringVar()
            if len(argv) > 1:
                self.files_var.set(" ".join(argv[1:]))
            
            self.files = argv[1:]
            tk.Label(self.files_frame,text="File list").grid(row=0,column=0)
            self.files_text = self.Entry(self.files_frame,textvariable=self.files_var,width=50)
            self.files_text.bind('<Return>',self.load_files)
            self.files_text.grid(row=0,column=1,padx=(0,3))
            tk.Button(self.files_frame,text="Load",command=self.load_files,width=5,height=1,padx=0,pady=0).grid(row=0,column=2)
            tk.Button(self.files_frame,text="Clear",command=self.clear_files,width=5,height=1,padx=0,pady=0).grid(row=0,column=3)
            self.current_file = tk.StringVar()
            self.last_file = tk.StringVar()
            self.current_file.set(self.files_var.get().split(" ")[0])
            self.last_file.set("")
            self.current_file_idx = tk.IntVar()
            self.current_file_idx.set(0)

        

        def init_colorbar():
            # Setup the colorbar
            self.colorbar = None
            self.cax_xbuff = tk.DoubleVar()
            self.cax_width = tk.DoubleVar()
            self.cax_buff = tk.DoubleVar() # A "universal" buffer that helps make space for tick labels and the axis label
            self.cax_xbuff.set(0.01)
            self.cax_width.set(0.05)
            self.cax_buff.set(0.)
            self.cax = self.fig.add_axes([self.x0.get()+self.w.get()+self.cax_xbuff.get(),self.y0.get(),self.cax_width.get(),self.h.get()]) # Right side by default
            self.cax.xaxis.set_visible(False)
            self.cax.yaxis.tick_right()

            # Setup colorbar label
            self.clabel_buff = tk.DoubleVar()
            self.clabel_buff.set(0.1)
            # The labels are initially blank
            self.clabel = self.fig.text(self.x0.get()+self.w.get()+self.cax_xbuff.get()+self.clabel_buff.get(),
                                        (2.*self.y0.get() + self.h.get())/2.,"",va='center',rotation='vertical')


        def init_user_plot_controls():
            # Beneath the graph, give user some controls
            self.skip_magnitude = tk.IntVar()
            self.skip_magnitude.set(1)
            self.skip_magnitude_entry = self.Entry(self.graph_controls_frame,textvariable=self.skip_magnitude,width=5)
            self.skip_magnitude_entry.grid(row=0,column=2)
            self.back_button = tk.Button(self.graph_controls_frame,command=self.previous_file,text="<<",width=2,height=1,padx=5,pady=5).grid(row=0,column=1)
            self.next_button = tk.Button(self.graph_controls_frame,command=self.next_file,text=">>",width=2,height=1,padx=5,pady=5).grid(row=0,column=3)
            self.current_file_label = tk.Label(self.graph_controls_frame,textvariable=self.current_file,padx=10).grid(row=0,column=0)

        def init_other_controls(): # Initialize some other controls for the user
            # Showing Roche lobes
            self.equalize_aspect_button = tk.Button(self.other_opts_frame,text="Equalize aspect ratio",command=self.equalize_aspect)
            self.equalize_aspect_button.grid(row=0,column=0)
            

        # Perform initialization
        init_graph()
        init_particle_controls()
        init_other_controls()
        init_axes_options()
        init_files_prompt()
        init_colorbar()
        init_user_plot_controls()
        
        
        # Draw the frames
        start = time()
        # Right side
        self.files_frame.grid(row=0,column=0,columnspan=2)
        self.axes_frame.grid(row=1,column=0,columnspan=2)
        self.particle_opts_frame.grid(row=2,column=0)
        self.other_opts_frame.grid(row=2,column=1)

        # Left side
        self.graph_frame.grid(row=0,column=0)
        self.graph_controls_frame.grid(row=1,column=1,sticky='E')
        self.graph_toolbar_frame.grid(row=1,column=0,sticky='W')
        
        self.left_frame.grid(row=0,column=0,columnspan=2)
        self.right_frame.grid(row=0,column=2)


        # Draw the first file
        if self.read_file() == 0:
            
            if self.sph_mode:
                self.variables = self.sph_variables
                self.color_variables = self.sph_color_variables
        
            # Set the axes to be the first 2 variables by default.
            self.axish_var.set(self.variables[0]) # x by default
            self.axisv_var.set(self.variables[1]) # y by default
            self.axisc_var.set(self.color_variables[0]) # Nothing by default
            self.axish_var_prev.set(self.axish_var.get())
            self.axisv_var_prev.set(self.axisv_var.get())
            self.axisc_var_prev.set(self.axisc_var.get())

            # When the axis variable changes from selecting the combobox, update the plot
        self.axish_var.trace('w',self.draw_plot)
        self.axisv_var.trace('w',self.draw_plot)
        self.axisc_var.trace('w',self.draw_plot)
        
        print(time()-start)
        
        self.draw_plot()













### The main draw function 
###########################

    def draw_plot(self,*args):
        # For now, return if there is no data to plot
        if self.data is None: return

        message = ""
        
        # Update the data in the plot
        self.clear_plot()

        xidx = [i for i in range(0,len(self.variables)) if self.variables[i] == self.axish_var.get()]
        yidx = [i for i in range(0,len(self.variables)) if self.variables[i] == self.axisv_var.get()]
        cidx = [i for i in range(0,len(self.color_variables)) if self.color_variables[i] == self.axisc_var.get()]

        if type(xidx).__name__ == 'list': xidx = xidx[0]
        if type(yidx).__name__ == 'list': yidx = yidx[0]
        if type(cidx).__name__ == 'list': cidx = cidx[0]

        if self.sph_mode:
            xyidxs = [xidx,yidx]
            xy = [None,None]
            for i,xyidx in enumerate(xyidxs):
                if xyidx == 18: # This is the divider
                    return
                elif xyidx == 19: # r
                    xy[i] = np.sqrt(np.sum(self.data[:,:3]**2.,axis=1))
                elif xyidx == 20: # r from particle 0
                    xy[i] = np.sqrt(np.sum((self.data[:,:3]-self.data[0][:3])**2.,axis=1))
                elif xyidx == 21: # mencl
                    r = np.sqrt(np.sum(self.data[:,:3]**2.,axis=1))
                    idx = np.argsort(r)
                    xy[i] = np.cumsum(self.data[idx][:,3])[np.argsort(idx)]
                elif xyidx == 22: # E = am*(grpot + 0.5*v^2 + u)
                    xy[i] = self.data[:,3]*(self.data[:,14] + 0.5*np.sum(self.data[:,6:9]**2.,axis=1) + self.data[:,12])
                else:
                    xy[i] = self.data[:,xyidx]
            if xy[0] is None or xy[1] is None:
                print("ERROR: Found 'None' type as the x-axis or y-axis data. xy =",xy)
                return # Just escape out if something bad is happening
            x, y = xy
        else:
            x = self.data[:,xidx]
            y = self.data[:,yidx]

        axish_canlog = np.all(x > 0)
        axisv_canlog = np.all(y > 0)
        
        if axish_canlog or self.axish_is10.get() == 1:
            self.axish_log_button.config(state='normal')
        else:
            self.axish_log_button.config(state='disabled')
        if axisv_canlog or self.axisv_is10.get() == 1:
            self.axisv_log_button.config(state='normal')
        else:
            self.axisv_log_button.config(state='disabled')
        
        # Do nothing if both buttons are selected
        if self.axish_islog.get() != self.axish_is10.get():
            if self.axish_islog.get() == 1:
                if axish_canlog:
                    x = np.log10(x)
                else:
                    message = "Cannot log Horizontal Axis, some values are <= 0"
                    self.axish_islog.set(0)
            elif self.axish_is10.get() == 1:
                x = 10.**x
                
        if self.axisv_islog.get() != self.axisv_is10.get():
            if self.axisv_islog.get() == 1:
                if axisv_canlog:
                    y = np.log10(y)
                else:
                    message = "Cannot log Vertical Axis, some values are <= 0"
                    self.axisv_islog.set(0)
            elif self.axisv_is10.get() == 1:
                y = 10.**y

        
        if self.axisc_var.get() == "":
            self.particle_controls(True)  # Show the particle plot controls
            self.colorbar_controls(False) # Hide the colorbar controls
            self.hide_colorbar()
            try:
                self.plot_particles(x,y)
            except ValueError as e:
                if "Unrecognized marker style" in str(e):
                    message = str(e)
                else:
                    raise ValueError(e)
            self.set_axish_limits(draw=False)
            self.set_axisv_limits(draw=False)
            self.update_particle_size(draw=False)
            self.update_particle_core_size(draw=False)
        else:
            self.particle_controls(False) # Hide the particle plot controls
            self.colorbar_controls(True)  # Show the colorbar controls

            if self.axisc_var.get() == self.sph_color_variables[1]: # column density
                # Figure out the z axis from the given x and y axes
                zidx = list(set([0,1,2]).difference(set([xidx,yidx])))[0]
                hpidx = [i for i in range(0,len(self.variables)) if self.variables[i] == "h"]
                if type(hpidx).__name__ == 'list': hpidx = hpidx[0]
                self.plot_column_density(x,y,self.data[:,zidx],self.data[:,3],self.data[:,hpidx])
                self.set_axisc_limits(draw=False)
                self.im.set_visible(True)
                self.show_colorbar()
                # Handle cases where the log button is already pressed
                if self.axisc_islog.get() == 1:
                    self.convert_log_axisc(draw=False)
                if self.axisc_is10.get() == 1:
                # Handle cases where the 10^ button is already pressed
                    self.convert_10_axisc(draw=False)
                
                # Should always be able to take the log of the column density (no negative values)
                self.axisc_log_button.config(state='normal')

        self.update_axis_labels()
        
        axis_vars = [self.axish_var,self.axisv_var,self.axisc_var]
        prev_axis_vars = [self.axish_var_prev,self.axisv_var_prev,self.axisc_var_prev]
        methods = [self.set_axish_limits,self.set_axisv_limits,self.set_axisc_limits]
        for i, (axis_var,prev_axis_var,method) in enumerate(zip(axis_vars,prev_axis_vars,methods)):
            if axis_var.get() != prev_axis_var.get():
                method(relim=True)
                prev_axis_vars[i].set(axis_vars[i].get())
        
        self.canvas.draw()
        
        # The code is left to hang after this point. Waiting for user input...
        self.corner_message_text.set(message)

###





### Plotting routines
###################### 
    def equalize_aspect(self,*args):
        # Get the x and y limits of the plot
        xlim = self.ax.get_xlim()
        ylim = self.ax.get_ylim()
        # If the aspect is already equal, then don't do anything
        if (xlim[1]-xlim[0]) == (ylim[1]-ylim[0]): return
        minlim = min(min(xlim),min(ylim))
        maxlim = max(max(xlim),max(ylim))
        current_center = [0.5*(xlim[1]+xlim[0]),0.5*(ylim[1]+ylim[0])]
        new_spacing = maxlim-minlim
        self.ax.set_xlim(current_center[0]-0.5*new_spacing,current_center[0]+0.5*new_spacing)
        self.ax.set_ylim(current_center[1]-0.5*new_spacing,current_center[1]+0.5*new_spacing)
        self.fig.canvas.draw()

    def plot_particle_kernels(self,draw=True,*args):
        if not self.sph_mode: return # If we are in SPH mode,
        # Check to make sure the plot has x, y, or z on both x and y axes
        if (self.axish_var.get() in ["x", "y", "z"] and self.axisv_var.get() in ["x", "y", "z"]) and \
           (self.axish_var.get() is not self.axisv_var.get()):
            if self.particle_kernel.get() == "1":
                self.corner_message_text.set("Plotting particle kernels...")
                self.corner_message_label.update_idletasks()
                if len(self.particle_kernels) == 0:
                    for particle in self.particles:
                        patches = [plt.Circle(center,size,fill=False,facecolor=None,edgecolor=self.particle_core_color.get()) for center, size in zip(particle.get_offsets(),2.*self.data[:,4])]
                        self.particle_kernels.append(self.ax.add_collection(PatchCollection(patches,match_original=True)))
                else:
                    for particle_kernel in self.particle_kernels:
                        particle_kernel.set_visible(True)
            else:
                for particle_kernel in self.particle_kernels:
                    particle_kernel.set_visible(False)
            if draw: self.canvas.draw()
            self.corner_message_text.set("")
            self.corner_message_label.update_idletasks()
            
                        
    def plot_core_particle_kernels(self,draw=True,*args):
        if not self.sph_mode: return # If we are in SPH mode,
        # Check to make sure the plot has x, y, or z on both x and y axes
        if (self.axish_var.get() in ["x", "y", "z"] and self.axisv_var.get() in ["x", "y", "z"]) and \
           (self.axish_var.get() is not self.axisv_var.get()):
            if self.particle_core_kernel.get() == "1":
                self.corner_message_text.set("Plotting core particle kernels...")
                self.corner_message_label.update_idletasks()
                if len(self.core_particle_kernels) == 0:
                    for core_particle in self.core_particles:
                        core_idx = np.where(self.data[:,12] == 0)[0] # True only in StarSmasher
                        if len(core_idx) > 0:
                            patches = [plt.Circle(center,size,fill=False,facecolor=None,edgecolor=self.particle_core_color.get()) for center, size in zip(core_particle.get_offsets(),2.*self.data[:,4][core_idx])]
                            self.core_particle_kernels.append(self.ax.add_collection(PatchCollection(patches,match_original=True)))
                else:
                    for core_particle_kernel in self.core_particle_kernels:
                        core_particle_kernel.set_visible(True)
            else:
                for core_particle_kernel in self.core_particle_kernels:
                    core_particle_kernel.set_visible(False)
            if draw: self.canvas.draw()
            self.corner_message_text.set("")
            self.corner_message_label.update_idletasks()
                
    def plot_particles(self,x,y,*args):    
        if self.sph_mode and not self.MESA_mode: # If we are in SPH mode,
            self.particles.append(self.ax.scatter(x,y,marker=self.particle_marker.get(),color=self.particle_color.get()))
            core_idx = np.where(self.data[:,12] == 0)[0] # True only in StarSmasher
            if len(core_idx) > 0:
                self.core_particles.append(self.ax.scatter(x[core_idx],y[core_idx],s=1,marker=self.particle_core_marker.get(),color=self.particle_core_color.get()))
        elif not self.sph_mode and self.MESA_mode: # If we are in MESA mode
            self.particles.append(self.ax.scatter(x,y,marker=self.particle_marker.get(),color=self.particle_color.get()))

        
        
    def plot_column_density(self,x,y,z,m,hp,*args):
        # Plot data with a colorbar

        # First, figure out how many pixels are on the screen
        xpix = self.resolution_scale_x.get()
        ypix = self.resolution_scale_y.get()
        zpix = self.resolution_scale_z.get()
        
        hp2 = np.multiply(hp,2.)
        
        # Determine the physical bounds of the grid
        xmin = np.amin(x-hp2)
        xmax = np.amax(x+hp2)
        ymin = np.amin(y-hp2)
        ymax = np.amax(y+hp2)
        zmin = np.amin(z-hp2)
        zmax = np.amax(z+hp2)

        xpos = np.linspace(xmin,xmax,xpix)
        ypos = np.linspace(ymin,ymax,ypix)
        zpos = np.linspace(zmin,zmax,zpix)

        try:
            #raise("Skip")
            import multiprocessing as mp
            
            nproc = mp.cpu_count()

            # We assume the image will never be too small (# x pixels < # processes)
            # Split the # of pixels in the x direction across all processes
            xpos_proc = np.array_split(xpos,nproc)

            # Keep track of the xpos indices
            xpos_idx_proc = np.array_split(np.arange(len(xpos),dtype=int),nproc)

            self.corner_message_text.set("Calculating column density in parallel...")
            self.corner_message_label.update_idletasks()
            
            start = time()
            q = mp.Queue()
            process = [None]*nproc
            for n in range(0,nproc):
                process[n] = mp.Process(target=self.calculate_coldens_mp, args=(q,x,y,z,m,hp, xpos_idx_proc[n], xpos_proc[n], ypos, zpos))
                process[n].start()

            xpos_idx_proc_calculated = [None]*nproc
            grids = [None]*nproc
            for n in range(0,nproc):
                res = q.get()
                xpos_idx_proc_calculated[n] = res[0]
                grids[n] = res[1]

            for proc in process:
                proc.join()

            grid = np.zeros((xpix,ypix))
            for n in range(0,nproc):
                grid_proc = grids[n]
                grid[xpos_idx_proc_calculated[n]] = grid_proc

        except Exception as e: # Multiprocessing failed, try doing it in serial
            print(e)
            print("Failed to calculate column density in parallel.")
            self.corner_message_text.set("Calculating column density in serial...")
            self.corner_message_label.update_idletasks()
            start = time()
            grid = self.calculate_coldens_serial(x,y,z,m,hp,xpos,ypos,zpos)
        print(time()-start)
        self.im = self.ax.imshow(grid.T,extent=(xmin,xmax,ymin,ymax),aspect=self.aspect.get(),cmap=self.cmap.get())
        self.corner_message_text.set("")

###





### Mathematical functions
###########################

    def init_kernels(self,*args):
        # Compute kernel tables
        def w(u):
            # Inspired by StarSmasher. This is a cubic spline kernel
            result = np.zeros(len(u))
            idx1 = u < 0
            idx2 = np.logical_and(u >= 0,u < 1)
            idx3 = np.logical_and(u >= 1, u < 2)

            result[idx1] = 1.
            result[idx2] = 1.+u[idx2]**2.*(-1.5+0.75*u[idx2])
            result[idx3] = 0.25*(2.-u[idx3])**3.
            
            result=result/np.pi

            return result
        
        
        u2 = 4.*np.arange(self.ntab-1) / float(self.ntab - 1)
        self.wtab = w(np.sqrt(u2))

    def calculate_coldens_serial(self,x,y,z,m,hp,xpos,ypos,zpos,*args):
        # Calculate the column density for this LOS (xpos,ypos)
        # Points along the LOS, zpos, are given and calculated outside this function
        # Returns an array of shape (len(xpos), len(ypos)). Each element of the
        # array is the column density at that (xpos, ypos).
        # We assume arrays x, y, z, m, and hp are all the same size

        N = np.shape(x)[0]
        
        hp2 = 2.*hp
        hp2p = hp**2.
        hp22 = 2.*hp2p
        hp3p = hp2p*hp

        xpix = np.shape(xpos)[0]
        ypix = np.shape(ypos)[0]
        zpix = np.shape(zpos)[0]

        thisgrid = np.zeros(shape=(xpix,ypix))
        
        # Filter first in the x direction
        my_y = y[:,None]
        my_z = z[:,None]
        my_ypos = ypos[:,None]
        my_zpos = zpos[:,None]
        dx2 = cdist(xpos[:,None],x[:,None],'sqeuclidean')
        idx_x = dx2 < hp22

        dens = np.zeros(zpix)
        
        for i in range(0,len(idx_x)):
            idx_xi = idx_x[i]
            if not np.any(idx_xi): continue
            
            my_L1_dx2 = dx2[i,idx_xi]
            my_L1_y = y[idx_xi]
            my_L1_z = z[idx_xi]
            my_L1_m = m[idx_xi]
            my_L1_hp = hp[idx_xi]
            my_L1_hp2 = hp2[idx_xi]
            my_L1_hp2p = hp2p[idx_xi]
            my_L1_hp22 = hp22[idx_xi]
            my_L1_hp3p = hp3p[idx_xi]

            dy2 = cdist(my_ypos,my_L1_y[:,None],'sqeuclidean')
            idx_y = dy2 < my_L1_hp22
            lenidx_y = len(idx_y)
            # Filter in the y direction
            for j in range(0,lenidx_y):
                idx_yj = idx_y[j]
                if not np.any(idx_yj): continue
                
                my_L2_dx2 = my_L1_dx2[idx_yj]
                my_L2_dy2 = dy2[j,idx_yj]
                my_L2_z = my_L1_z[idx_yj]
                my_L2_m = my_L1_m[idx_yj]
                my_L2_hp = my_L1_hp[idx_yj]
                my_L2_hp2 = my_L1_hp2[idx_yj]
                my_L2_hp2p = my_L1_hp2p[idx_yj]
                my_L2_hp22 = my_L1_hp22[idx_yj]
                my_L2_hp3p = my_L1_hp3p[idx_yj]

                dz2 = cdist(my_zpos,my_L2_z[:,None],'sqeuclidean')
                idx_z = dz2 < my_L2_hp22
                lenidx_z = len(idx_z)
                # Filter in the z direction
                for k in range(0,lenidx_z):
                    idx_zk = idx_z[k]
                    if not np.any(idx_zk):
                        dens[k] = 0.
                        continue
                    my_L3_dx2 = my_L2_dx2[idx_zk]
                    my_L3_dy2 = my_L2_dy2[idx_zk]
                    my_L3_dz2 = dz2[k,idx_zk]
                    my_L3_m = my_L2_m[idx_zk]
                    my_L3_hp = my_L2_hp[idx_zk]
                    my_L3_hp2 = my_L2_hp2[idx_zk]
                    my_L3_hp2p = my_L2_hp2p[idx_zk]
                    my_L3_hp22 = my_L2_hp22[idx_zk]
                    my_L3_hp3p = my_L2_hp3p[idx_zk]

                    dr2 = my_L3_dx2 + my_L3_dy2 + my_L3_dz2

                    idx = dr2 < my_L3_hp22
                    if not np.any(idx): continue

                    indices = (self.ctab * dr2[idx]/my_L3_hp2p[idx]).astype(np.int,copy=False)
                    wpc = self.wtab[indices] / my_L3_hp3p[idx]
                    dens[k] = (my_L3_m[idx] * wpc).sum()
                thisgrid[i][j] = simps(dens,x=zpos)

        return thisgrid

        
    def calculate_coldens_mp(self,queue,x,y,z,m,hp,xpos_idx_proc,xpos,ypos,zpos,*args):
        queue.put([xpos_idx_proc,self.calculate_coldens_serial(x,y,z,m,hp,xpos,ypos,zpos,*args)])

###





### Updating functions
#######################

    def update_particle_core_kernel_button(self,*args):
        if self.particle_core_kernel_button['relief'] == 'raised':
            self.particle_core_kernel.set("1")
            self.particle_core_kernel_button.config(relief='sunken')
        elif self.particle_core_kernel_button['relief'] == 'sunken':
            self.particle_core_kernel.set("0")
            self.particle_core_kernel_button.config(relief='raised')
        self.plot_core_particle_kernels()

    def update_particle_kernel_button(self,*args):
        if self.particle_kernel_button['relief'] == 'raised':
            self.particle_kernel.set("1")
            self.particle_kernel_button.config(relief='sunken')
        elif self.particle_kernel_button['relief'] == 'sunken':
            self.particle_kernel.set("0")
            self.particle_kernel_button.config(relief='raised')
        self.plot_particle_kernels()

    def update_axisc_10_button(self,*args):
        if self.axisc_10_button['relief'] == 'raised':
            self.axisc_is10.set(1)
            self.axisc_10_button.config(relief='sunken')
        elif self.axisc_10_button['relief'] == 'sunken':
            self.axisc_is10.set(0)
            self.axisc_10_button.config(relief='raised')
        self.convert_10_axisc()

    def update_axisc_log_button(self,*args):
        if self.axisc_log_button['relief'] == 'raised':
            self.axisc_islog.set(1)
            self.axisc_log_button.config(relief='sunken')
        elif self.axisc_log_button['relief'] == 'sunken':
            self.axisc_islog.set(0)
            self.axisc_log_button.config(relief='raised')
        self.convert_log_axisc()

    def update_axisc_adaptive_button(self,*args):
        if self.axisc_adaptive_button['relief'] == 'raised':
            self.axisc_isadaptive.set(1)
            self.axisc_adaptive_button.config(relief='sunken')
        elif self.axisc_adaptive_button['relief'] == 'sunken':
            self.axisc_isadaptive.set(0)
            self.axisc_adaptive_button.config(relief='raised')
        self.set_axisc_limits()

    def update_axisv_10_button(self,*args):
        if self.axisv_10_button['relief'] == 'raised':
            self.axisv_is10.set(1)
            self.axisv_10_button.config(relief='sunken')
        elif self.axisv_10_button['relief'] == 'sunken':
            self.axisv_is10.set(0)
            self.axisv_10_button.config(relief='raised')
        self.draw_plot()

    def update_axisv_log_button(self,*args):
        if self.axisv_log_button['relief'] == 'raised':
            self.axisv_islog.set(1)
            self.axisv_log_button.config(relief='sunken')
        elif self.axisv_log_button['relief'] == 'sunken':
            self.axisv_islog.set(0)
            self.axisv_log_button.config(relief='raised')
        self.draw_plot()

    def update_axisv_adaptive_button(self,*args):
        if self.axisv_adaptive_button['relief'] == 'raised':
            self.axisv_isadaptive.set(1)
            self.axisv_adaptive_button.config(relief='sunken')
        elif self.axisv_adaptive_button['relief'] == 'sunken':
            self.axisv_isadaptive.set(0)
            self.axisv_adaptive_button.config(relief='raised')
        self.set_axisv_limits()

    def update_axish_10_button(self,*args):
        if self.axish_10_button['relief'] == 'raised':
            self.axish_is10.set(1)
            self.axish_10_button.config(relief='sunken')
        elif self.axish_10_button['relief'] == 'sunken':
            self.axish_is10.set(0)
            self.axish_10_button.config(relief='raised')
        self.draw_plot()

    def update_axish_log_button(self,*args):
        if self.axish_log_button['relief'] == 'raised':
            self.axish_islog.set(1)
            self.axish_log_button.config(relief='sunken')
        elif self.axish_log_button['relief'] == 'sunken':
            self.axish_islog.set(0)
            self.axish_log_button.config(relief='raised')
        self.draw_plot()

    def update_axish_adaptive_button(self,*args):
        if self.axish_adaptive_button['relief'] == 'raised':
            self.axish_isadaptive.set(1)
            self.axish_adaptive_button.config(relief='sunken')
        elif self.axish_adaptive_button['relief'] == 'sunken':
            self.axish_isadaptive.set(0)
            self.axish_adaptive_button.config(relief='raised')
        self.set_axish_limits()

    def update_cmap(self,draw=True,*args):
        try:
            if int(self.cmap_idx.get()) in np.arange(len(self.cmap_names)):
                self.cmap.set(self.cmap_names[int(self.cmap_idx.get())])
        except ValueError:
            # The user did not use an integer value
            return
        self.colorbar.mappable.set_cmap(self.cmap.get())
        if draw: self.canvas.draw()

    def update_axis_labels(self,*args):
        label_log = "log "
        label_10 = "10^ "
        
        hlabel_str = ""
        if self.axish_islog.get() == 1 and self.axish_is10.get() == 0: # Only log10
            hlabel_str += label_log
        elif self.axish_islog.get() == 0 and self.axish_is10.get() == 1: # Only 10^
            hlabel_str += label_10
        self.hlabel.set_text(hlabel_str+self.axish_var.get())

        vlabel_str = ""
        if self.axisv_islog.get() == 1 and self.axisv_is10.get() == 0: # Only log10
            vlabel_str += label_log
        elif self.axisv_islog.get() == 0 and self.axisv_is10.get() == 1: # Only 10^
            vlabel_str += label_10
        self.vlabel.set_text(vlabel_str+self.axisv_var.get())

        clabel_str = ""
        if self.cax.get_visible():
            if self.axisc_islog.get() == 1 and self.axisc_is10.get() == 0: # Only log10
                clabel_str += label_log
            elif self.axisc_islog.get() == 0 and self.axisc_is10.get() == 1: # Only 10^
                clabel_str += label_10
        self.clabel.set_text(clabel_str+self.axisc_var.get())
            
        # Reposition the labels
        self.hlabel.set_position(((self.x0.get()+self.w.get()+self.x0.get())/2.,self.y0.get() - self.hlabel_buff.get()))
            
    def update_axes_menu(self,*args):
        self.axish_combobox.config(values=list(self.variables))
        self.axisv_combobox.config(values=list(self.variables))
        self.axisc_combobox.config(values=list(self.color_variables))

    def update_log_10_buttons(self,x,y,*args):
        if np.all(x > 0):
            # The horizontal axis is able to be in log space
            self.axish_log_button.config(state='normal')
        elif self.axish_is10.get() == 0: #10^ button is not selected
            self.axish_islog.set(0)
            self.axish_log_button.config(state='disabled')
 
        if np.all(y > 0):
            # The vertical axis is able to be in log space
            self.axisv_log_button.config(state='normal')
        elif self.axisv_is10.get() == 0: #10^ button is not selected
            self.axisv_islog.set(0)
            self.axisv_log_button.config(state='disabled')

###





### Color choosers
###################

    def choose_particle_color(self,*args):
        color = colorchooser.askcolor(parent=self.root,initialcolor=self.particle_color.get())[1]
        if color is not None:
            self.particle_color.set(color)
            self.particle_color_button.config(bg=self.particle_color.get())
        self.update_particle_color()
        
    def choose_particle_core_color(self,*args):
        color = colorchooser.askcolor(parent=self.root,initialcolor=self.particle_core_color.get())[1]
        if color is not None:
            self.particle_core_color.set(color)
            self.particle_core_color_button.config(bg=self.particle_core_color.get())
        self.update_particle_core_color()

###






### Plot controls
##################

    def save_axish_limits(self,*args):
        self.xlim = self.ax.get_xlim()
        # Unset adaptive limits (assuming the user doesn't want to have adaptive limits now)
        if self.axish_adaptive_button['relief'] == 'sunken':
            self.axish_isadaptive.set(0)
            self.axish_adaptive_button.config(relief='raised')
        self.corner_message_text.set("Saved current horizontal axis limits")
        self.corner_message_label.update_idletasks()

    def save_axisv_limits(self,*args):
        self.ylim = self.ax.get_ylim()
        # Unset adaptive limits (assuming the user doesn't want to have adaptive limits now)
        if self.axisv_adaptive_button['relief'] == 'sunken':
            self.axisv_isadaptive.set(0)
            self.axisv_adaptive_button.config(relief='raised')
        self.corner_message_text.set("Saved current vertical axis limits")
        self.corner_message_label.update_idletasks()

    def save_axisc_limits(self,*args):
        self.clim = self.colorbar.mappable.get_clim()
        # Unset adaptive limits (assuming the user doesn't want to have adaptive limits now)
        if self.axisc_adaptive_button['relief'] == 'sunken':
            self.axisc_isadaptive.set(0)
            self.axisc_adaptive_button.config(relief='raised')
        self.corner_message_text.set("Saved current colorbar limits")
        self.corner_message_label.update_idletasks()
            

    def set_axish_limits(self,*args,draw=True,relim=False):
        if self.axish_isadaptive.get() == 1 or relim:
            xmin = np.inf
            xmax = -np.inf
            for child in self.ax.get_children():
                if type(child).__name__ == 'PathCollection':
                    xy = child.get_offsets()
                    xmin = min(xmin,np.amin(xy[:,0]))
                    xmax = max(xmax,np.amax(xy[:,0]))
            dx = xmax-xmin
            xmargin, ymargin = self.ax.margins()
            self.ax.set_xlim(xmin-dx*xmargin,xmax+dx*xmargin)
        else:
            self.ax.set_xlim(self.xlim)
        if draw: self.canvas.draw()

    def set_axisv_limits(self,*args,draw=True,relim=False):
        if self.axisv_isadaptive.get() == 1 or relim:
            ymin = np.inf
            ymax = -np.inf
            for child in self.ax.get_children():
                if type(child).__name__ == 'PathCollection':
                    xy = child.get_offsets()
                    ymin = min(ymin,np.amin(xy[:,1]))
                    ymax = max(ymax,np.amax(xy[:,1]))
            dy = ymax-ymin
            xmargin, ymargin = self.ax.margins()
            self.ax.set_ylim(ymin-dy*ymargin,ymax+dy*ymargin)
        else:
            self.ax.set_ylim(self.ylim)
        if draw: self.canvas.draw()

    def set_axisc_limits(self,*args,draw=True,relim=False):
        if self.cax.get_visible() and self.im is not None:
            if self.axisc_isadaptive.get() == 1 or relim:
                arr = self.im.get_array()

                # Reset the limits on the colorbar
                margin = self.cax.margins()
                vmin = np.amin(arr[np.isfinite(arr)])
                vmax = np.amax(arr[np.isfinite(arr)])
                dv = vmax-vmin
                vmin_new = vmin - dv*margin[1]
                vmax_new = vmax + dv*margin[1]
                if self.axisc_var.get() == self.sph_color_variables[1]: # column density
                    if self.axisc_islog.get() == 0 or self.axisc_islog.get() == self.axisc_is10.get(): # Not logged
                        # Can't have any values less than zero
                        if vmin_new < 0: vmin_new = 0
                        if vmax_new < 0: vmax_new = 0
                self.colorbar.mappable.set_clim(vmin_new, vmax_new)
            else:
                self.colorbar.mappable.set_clim(self.clim)
            if draw: self.canvas.draw()

    def particle_controls(self,show,*args):
        if show:
            self.particle_color_button.config(state='normal')
            self.particle_core_color_button.config(state='normal')
            self.particle_size_entry.config(state='normal')
            self.particle_core_size_entry.config(state='normal')
            self.particle_marker_combobox.config(state='normal')
            self.particle_core_marker_combobox.config(state='normal')
            if (self.axish_islog.get() == self.axisv_islog.get()) and \
               (self.axish_var.get() in ["x", "y", "z"] and self.axisv_var.get() in ["x", "y", "z"]) and \
               (self.axish_var.get() is not self.axisv_var.get()):
                self.particle_kernel_button.config(state='normal')
                self.particle_core_kernel_button.config(state='normal')
        else:
            self.particle_color_button.config(state='disabled')
            self.particle_core_color_button.config(state='disabled')
            self.particle_size_entry.config(state='disabled')
            self.particle_core_size_entry.config(state='disabled')
            self.particle_marker_combobox.config(state='disabled')
            self.particle_core_marker_combobox.config(state='disabled')
            if not ((self.axish_islog.get() == self.axisv_islog.get()) and \
                    (self.axish_var.get() in ["x", "y", "z"] and self.axisv_var.get() in ["x", "y", "z"]) and \
                    (self.axish_var.get() is not self.axisv_var.get())):
                self.particle_kernel_button.config(state='disabled')
                self.particle_core_kernel_button.config(state='disabled')
            
            
    def colorbar_controls(self,show,*args):
        if show:
            self.cmap_next_button.config(state='normal')
            self.cmap_previous_button.config(state='normal')
            self.cmap_entry.config(state='normal')
            self.resolution_draw_button.config(state='normal')
            self.axisc_save_limits_button.config(state='normal')
        else:
            self.cmap_next_button.config(state='disabled')
            self.cmap_previous_button.config(state='disabled')
            self.cmap_entry.config(state='disabled')
            self.resolution_draw_button.config(state='disabled')
            #self.axisc_log_button.config(state='disabled')
            self.axisc_save_limits_button.config(state='disabled')

    def update_particle_color(self,draw=True,*args):
        for particles in self.particles:
            particles.set_color(self.particle_color.get())
        for kernels in self.particle_kernels:
            kernels.set_edgecolor(self.particle_color.get())
        if draw: self.canvas.draw()

    def update_particle_core_color(self,draw=True,*args):
        for core_particles in self.core_particles:
            core_particles.set_color(self.particle_core_color.get())
        for core_kernels in self.core_particle_kernels:
            core_kernels.set_edgecolor(self.particle_core_color.get())
        if draw: self.canvas.draw()

    def update_particle_size(self,draw=True,*args):
        try:
            psize = float(self.particle_size.get())
        except ValueError:
            return
        
        for particles in self.particles:
            particles.set_sizes([psize])
        if draw: self.canvas.draw()
        
    def update_particle_core_size(self,draw=True,*args):
        try:
            psize = float(self.particle_core_size.get())
        except ValueError:
            return
        
        for core_particles in self.core_particles:
            core_particles.set_sizes([psize])
        if draw: self.canvas.draw()

    def update_particle_marker(self,*args):
        # Matplotlib has no functionality for cleanly updating the markers, very unfortunate...
        self.draw_plot()

    def update_particle_core_marker(self,*args):
        # Matplotlib has no functionality for cleanly updating the markers, very unfortunate...
        self.draw_plot()

    def clear_plot(self,*args):
        for particles in self.particles:
            particles.remove()
            self.particles.remove(particles)
        for core_particles in self.core_particles:
            core_particles.remove()
            self.core_particles.remove(core_particles)
        for kernels in self.particle_kernels:
            kernels.remove()
            self.particle_kernels.remove(kernels)
        for core_kernels in self.core_particle_kernels:
            core_kernels.remove()
            self.core_particle_kernels.remove(core_kernels)
        if self.im is not None:
            self.im.set_visible(False)

    def change_axis_state(self,axis,state,*args):
        # Disables/enables everything related to the input axis
        # axis = str
        # state = str
        
        if axis == "axish":
            if state == 'normal':
                self.axish_combobox.config(state='readonly')
            else:
                self.axish_combobox.config(state=state)
            self.axish_log_button.config(state=state)
            self.axish_10_button.config(state=state)
            self.axish_adaptive_button.config(state=state)
            self.axish_save_limits_button.config(state=state)
        elif axis == "axisv":
            if state == 'normal':
                self.axisv_combobox.config(state='readonly')
            else:
                self.axisv_combobox.config(state=state)
            self.axisv_log_button.config(state=state)
            self.axisv_10_button.config(state=state)
            self.axisv_adaptive_button.config(state=state)
            self.axisv_save_limits_button.config(state=state)
        elif axis == "axisc":
            if state == 'normal':
                self.axisc_combobox.config(state='readonly')
            else:
                self.axisc_combobox.config(state=state)
            self.axisc_log_button.config(state=state)
            self.axisc_10_button.config(state=state)
            self.axisc_adaptive_button.config(state=state)
            self.axisc_save_limits_button.config(state=state)
            self.resolution_scale_x_entry.config(state=state)
            self.resolution_scale_y_entry.config(state=state)
            self.resolution_scale_z_entry.config(state=state)
            self.resolution_draw_button.config(state=state)
            self.cmap_entry.config(state=state)
            
    def show_colorbar(self,*args):
        # Draw the colorbar relative to the axis
        
        # If the colorbar doesn't exist yet, create it
        if self.colorbar is None:
                self.colorbar = self.fig.colorbar(self.im,cax=self.cax)

        if not self.cax.get_visible() and self.axisc_var.get() != "": # Colorbar must not be visible and a selection must be made
            self.cax.set_visible(True)
            # Adjust the size of the axis to accommodate the colorbar
            colorbar_xsize = self.cax_xbuff.get() + self.cax_width.get() + self.cax_buff.get()
            new_width = self.w.get() - colorbar_xsize
            pos = self.ax.get_position()
            self.ax.set_position([pos.x0,pos.y0,new_width,pos.height])
            pos = self.ax.get_position()
            # For now, draw colorbar to the right side only
            self.cax.set_position([self.x0.get()+new_width + self.cax_xbuff.get(),pos.y0,self.cax_width.get(),pos.height])
            
    def hide_colorbar(self,*args):
        # Undo what happens in show_colorbar
        if self.cax.get_visible() and self.axisc_var.get() == "":
            self.cax.set_visible(False)
            self.ax.set_position([self.x0.get(),self.y0.get(),self.w.get() + (self.cax_xbuff.get() + self.cax_width.get() + self.cax_buff.get()), self.h.get()])

    def next_cmap(self,*args):
        # Go to the next colormap
        try:
            nxt = int(self.cmap_idx.get())+1
        except ValueError: # If we can't convert to an int, just do nothing
            return
        if nxt > len(self.cmap_names)-1: nxt = 0
        self.cmap_idx.set(nxt)
        self.update_cmap()
        
    def previous_cmap(self,*args):
        # Go to the previous colormap
        try:
            nxt = int(self.cmap_idx.get())-1
        except ValueError: # If we can't convert to an int, just do nothing
            return
        if nxt < 0: nxt = len(self.cmap_names)-1
        self.cmap_idx.set(nxt)
        self.update_cmap()

    def convert_log_axisc(self,draw=True,*args):
        # Convert the color axis to log
        if self.im is not None:
            arr = self.im.get_array()
            if self.axisc_islog.get() != 0: # Log the data
                idx = arr == 0
                idx_invert = np.logical_not(idx)
                arr[idx] = np.nan
                arr[idx_invert] = np.log10(arr[idx_invert])
            else: # Unlog the data
                idx = np.isnan(arr)
                idx_invert = np.logical_not(idx)
                arr[idx] = 0.
                arr[idx_invert] = 10.**arr[idx_invert]

            self.im.set_array(arr)

            # Reset the limits on the colorbar
            margin = self.cax.margins()
            vmin = np.amin(arr[np.isfinite(arr)])
            vmax = np.amax(arr[np.isfinite(arr)])
#            print(vmin,vmax)
            dv = vmax-vmin
            vmin_new = vmin - dv*margin[1]
            vmax_new = vmax + dv*margin[1]
            if self.axisc_var.get() == self.sph_color_variables[1]: # column density
                if self.axisc_islog.get() == 0 or self.axisc_islog.get() == self.axisc_is10.get(): # Not logged
                    # Can't have any values less than zero
                    if vmin_new < 0: vmin_new = 0
                    if vmax_new < 0: vmax_new = 0

            self.im.set_clim(vmin=vmin_new,vmax=vmax_new)
            self.colorbar.mappable.set_clim(vmin_new, vmax_new)
            
            # Update the axis labels
            self.update_axis_labels()
            
            if draw: self.canvas.draw()
        
    def convert_10_axisc(self,draw=True,*args):
        # Convert the color axis to 10^
        if self.im is not None:
            arr = self.im.get_array()
            if self.axisc_is10.get() == 0: # Log the data
                idx = arr == 0
                idx_invert = np.logical_not(idx)
                arr[idx] = np.nan
                arr[idx_invert] = np.log10(arr[idx_invert])
            else: # Unlog the data
                idx = np.isnan(arr)
                idx_invert = np.logical_not(idx)
                arr[idx] = 0.
                arr[idx_invert] = 10.**arr[idx_invert]

            self.im.set_array(arr)

            # Reset the limits on the colorbar
            margin = self.cax.margins()
            vmin = np.amin(arr[np.isfinite(arr)])
            vmax = np.amax(arr[np.isfinite(arr)])
            dv = vmax-vmin
            vmin_new = vmin - dv*margin[1]
            vmax_new = vmax + dv*margin[1]
            if self.axisc_var.get() == self.sph_color_variables[1]: # column density
                if self.axisc_islog.get() == 0 or self.axisc_islog.get() == self.axisc_is10.get(): # Not logged
                    # Can't have any values less than zero
                    if vmin_new < 0: vmin_new = 0
                    if vmax_new < 0: vmax_new = 0
            self.colorbar.mappable.set_clim(vmin_new, vmax_new)

            # Update the axis labels
            self.update_axis_labels()
            
            if draw: self.canvas.draw()

    
                
###





### File controls
##################

    def load_files(self,*args):
        self.files = []
        for f in self.files_var.get().split(" "):
            if "*" in f:
                self.files.extend(sorted(glob(f)))
            else:
                self.files.extend(glob(f))
                
        self.draw_plot()
        self.corner_message_text.set("File list loaded")
        self.corner_message_label.update_idletasks()
 
    def clear_files(self,*args):
        self.files = []
        self.files_var.set("")
        
    def read_file(self,*args):
        # Start the "Loading..." message when we start to read the data, and get rid of the message
        # after we have plotted the data (in draw_plot())

        # Return the following error code:
        # 0 = Successful
        # 1 = The file does not exist
        # 2 = The file is the same as the previous one read in
        # 3 = Unrecognized file type

        # First check to see if the file actually exists
        if not isfile(self.current_file.get()):
            if len(self.current_file.get()) > 20:
                self.corner_message_text.set("Could not find file ..."+self.current_file.get())
            else:
                self.corner_message_text.set("Could not find file "+self.current_file.get())
            self.corner_message_label.update_idletasks()
            return 1
        
        # First check to see if we have changed files since the last time we read data
        if self.current_file.get() == self.last_file.get():
            # If so, we don't need to do anything
            return 2
        
        self.corner_message_text.set("Loading...")
        self.corner_message_label.update_idletasks()
        self.data, self.header = read_binary(self.current_file.get())
        
        if self.data is not None and self.header is not None:
            # This is an SPH file
            self.variables = self.sph_variables
            self.color_variables = self.sph_color_variables

            # Enable the colorbar menu
            self.change_axis_state("axisc",'normal')
            
            self.sph_mode = True
            self.MESA_mode = False
        else:
            # This is some other file

            # Check if it is a mesa file
            header_attr, cols, data = read_mesa(self.current_file.get())
            if header_attr is not None and cols is not None and data is not None:
                keys = np.asarray(list(cols.items()))[:,0]
                values = np.asarray(list(cols.items()))[:,1].astype(int)
                self.variables = keys[np.argsort(values)]
                self.color_variables = [ "" ] # No colorbars for MESA files
                self.data = data
                self.MESA_mode = True
                self.sph_mode = False

                # Disable the colorbar menu
                self.change_axis_state("axisc","disabled")
            else:
                # Unrecognized file format
                self.corner_message_text.set("Unrecognized file type '"+self.current_file.get()+"'")
                self.corner_message_label.update_idletasks()
        
                # Disable the menu buttons
                self.change_axis_state("axish","disabled")
                self.change_axis_state("axisv","disabled")

                self.sph_mode = False
                self.MESA_mode = False
                
                return 3

        self.last_file.set(self.current_file.get())
            
        self.change_axis_state("axish","normal")
        self.change_axis_state("axisv","normal")
        
        self.update_axes_menu()
        
        return 0

    def next_file(self,*args):
        nxt_idx = self.current_file_idx.get() + self.skip_magnitude.get()
        #currentfile = self.current_file.get()
        #currentfileidx = self.current_file_idx.get()
        if nxt_idx >= len(self.files)-1:
            # Reached end of file list
            if self.current_file_idx.get() != len(self.files)-1:
                self.current_file_idx.set(len(self.files)-1)
                self.current_file.set(self.files[-1])
                isread = self.read_file()
                if isread == 0: # Successfully read the last file in the list
                    self.draw_plot()
            
            self.corner_message_text.set("End of file list")
            self.corner_message_label.update_idletasks()
            self.skip_magnitude_entry.delete(0,'end')
            self.skip_magnitude_entry.insert(0,'1')
            self.skip_magnitude.set(1)
            return

        self.current_file_idx.set(nxt_idx)
        self.current_file.set(self.files[self.current_file_idx.get()])
        isread = self.read_file()
        if isread == 0: self.draw_plot()
        
    def previous_file(self,*args):
        prev_idx = self.current_file_idx.get() - self.skip_magnitude.get()
        currentfile = self.current_file.get()
        currentfileidx = self.current_file_idx.get()
        if prev_idx <= 0:
            # Reached beginning of file list
            if self.current_file_idx.get() != 0:
                self.current_file_idx.set(0)
                self.current_file.set(self.files[0])
                isread = self.read_file()
                if isread == 0:
                    self.draw_plot()
                return
                    
            self.corner_message_text.set("Start of file list")
            self.corner_message_label.update_idletasks()
            self.skip_magnitude_entry.delete(0,'end')
            self.skip_magnitude_entry.insert(0,'1')
            self.skip_magnitude.set(1)
            return

        self.current_file_idx.set(prev_idx)
        self.current_file.set(self.files[self.current_file_idx.get()])
        isread = self.read_file()
        if isread == 0: self.draw_plot()

###




### Code execution
###################

# If this isn't here, tkinter will keep slowing down every time it is reopened...
def close(*args):
    root.destroy()

# This prevents tkinter from slowing down by first closing tkinter before printing traceback
# whenever an error occurs
def handleException(excType, excValue, trace):
    close()
    original_excepthook(excType,excValue,trace)
    
if __name__ == '__main__':
    original_excepthook = excepthook
    excepthook = handleException
    root = tk.Tk()
    root.wm_title("PySplash")
    root.protocol("WM_DELETE_WINDOW",close)
    signal(SIGINT, close)
    main(root)
    root.mainloop()

###
