#!/usr/bin/env python3

#from __future__ import print_function # Allows python2 and python3 functionality

#try:
#    import tkinter as tk # Python 3
#    from tkinter.colorchooser import askcolor
#except ImportError:
#    import Tkinter as tk # Python 2
#    from Tkinter.colorchooser import askcolor

import tkinter as tk # Python 3 only for now
from tkinter import colorchooser

from matplotlib.backends.backend_tkagg import (
    FigureCanvasTkAgg, NavigationToolbar2Tk)
# Implement the default Matplotlib key bindings.
from matplotlib.backend_bases import key_press_handler
from matplotlib.figure import Figure
    
import matplotlib.pyplot as plt
from glob import glob
import sys
import numpy as np
import time
import multiprocessing as mp



units = [ "6.9599e10",
          "1.9891e33",
        ]

def read_sph(filename,
         return_header=True,
         return_data=True,
         fmt_header= '2i'+    # ntot, nnopt (2*4=8)
                     '5d'+    # hco, hfloor, sep0, tf, dtout (8*5=40)
                     '2i'+    # nout, nit (2*4=8)
                     'd'+     # t (8)
                     'i'+     # nav (4)
                     '3d'+    # alpha, beta, tjumpahead (3*8=24)
                     '2i'+    # ngr, nrelax (4*2=8)
                     '3d'+    # trelax, dt, omega2 (3*8=24)
                     'i'+     # ncooling (4)
                     'd'+     # erad (8)
                     'i'+     # ndisplace (4)
                     '3d',    # displacex, displacey, displacez (4*8=24),
         fmt_dataline= 'f8,'+ # x
                       'f8,'+ # y
                       'f8,'+ # z
                       'f8,'+ # am
                       'f8,'+ # hp
                       'f8,'+ # rho
                       'f8,'+ # vx
                       'f8,'+ # vy
                       'f8,'+ # vz
                       'f8,'+ # vxdot
                       'f8,'+ # vydot
                       'f8,'+ # vzdot
                       'f8,'+ # u
                       'f8,'+ # udot
                       'f8,'+ # grpot
                       'f8,'+ # meanmolecular
                       'f4,'+ # cc
                       'f8',  # divv
         fmt_extra='',
         size_header=164,
         size_dataline=156,
         size_extra=0,
         lines=0):
    import struct
    import numpy as np
    import sys
    from numpy.lib.recfunctions import repack_fields

    if fmt_extra != '': fmt_extra = ','+fmt_extra
    dsize = size_dataline+size_extra+8
    
    with open(filename,'rb') as f:
        header = np.asarray(struct.unpack('<i'+fmt_header+'d', f.read(4+size_header+8)))[1:-1]
        if lines == 0: lines = int(header[0])

        if int(header[19]) != 0: #if ncooling =/= 0
            fmt_dataline += ',f8,f8'
            dsize+=16

        if return_data:
            try:
                #data = np.ndarray(shape=(1,lines),
                #                  dtype=np.dtype(fmt_dataline+fmt_extra+',f8'),
                #                  buffer=f.read(lines*dsize))[0].astype(dsize*'f8,').view(dtype='f8').reshape(lines,dsize)[:,:-1]
            
                dtype = fmt_dataline+fmt_extra+',f8'
                data = np.zeros((lines,dtype.count(',')+1))
                
                data[:] = np.ndarray(shape=(1,lines),
                                     dtype=np.dtype(dtype),
                                     buffer=f.read(lines*dsize))[0].tolist()[:]
                data=data[:,:-1]
                
            except:
                data = None
                header = None
            

            if return_header: return data,header
            else: return data
        else:
            if return_header: return header


def _read_mesafile(filename, data_rows=0, only='all'):
    # Taken from mesa_read.py written by Kenny X. Van
    ''' private routine that is not directly called by the user'''
    f = open(filename, 'r')
    vv = []
    v = []
    lines = []
    line = ''
    for i in range(0, 6):
        line = f.readline()
        lines.extend([line])

    hval = lines[2].split()
    hlist = lines[1].split()
    header_attr = {}
    for a, b in zip(hlist, hval):
        header_attr[a] = float(b)
    if only is 'header_attr':
        return header_attr

    cols = {}
    colnum = lines[4].split()
    colname = lines[5].split()
    for a, b in zip(colname, colnum):
        cols[a] = int(b)

    data = []

    for i in range(data_rows):
        line = f.readline()
        v = line.split()
        try:
            vv = np.array(v, dtype='float64')
        except ValueError:
            for item in v:
                if item.__contains__('.') and not item.__contains__('E'):
                    v[v.index(item)] = '0'
        data.append(vv)

    #print ' \n'
    f.close()
    a = np.array(data)
    data = []
    return header_attr, cols, a
            
def read_mesa(filename):
    header_attr = _read_mesafile(filename, only='header_attr')
    try:
        num_zones = int(header_attr['num_zones'])
    except KeyError:
        return None,None,None

    header_attr, cols, data = _read_mesafile(filename, data_rows=num_zones, only='all')
    return header_attr,cols,data


def rgb2tk(rgb):
    """translates an rgb tuple of int to a tkinter friendly color code
    """
    return "#%02x%02x%02x" % rgb

class CustomToolbar(NavigationToolbar2Tk):
    def __init__(self,canvas_,parent_):
        self.toolitems = (
            (u'Home', u'Reset original view', u'home', u'home'),
            (u'Pan', u'Pan axes with left mouse, zoom with right', u'move', u'pan'),
            (u'Zoom', u'Zoom to rectangle', u'zoom_to_rect', u'zoom'),
            (u'Subplots', u'Configure subplots', u'subplots', u'configure_subplots'),
            (u'Save', u'Save the figure', u'filesave', u'save_figure'),
            )
        NavigationToolbar2Tk.__init__(self,canvas_,parent_)

class main():
    
    def __init__(self,root):
        self.root = root

        # Init kernels for SPH code
        self.ntab = 100000 # ntab = 100000 from StarSmasher
        self.ctab = float(self.ntab - 1)/4.
        self.init_kernels() # Cubic spline only for now
        
        self.data = None
        self.header = None

        # Assume an SPH data file by default
        self.variables = [ "x",
                           "y",
                           "z",
                           "m",
                           "h",
                           "rho",
                           "vx",
                           "vy",
                           "vz",
                           "vxdot",
                           "vydot",
                           "vzdot",
                           "u",
                           "udot",
                           "grpot",
                           "meanmolecular",
                           "cc",
                           "divv",
                         ]
        self.color_variables = [ "",
                                 "column density",
                               ]
        self.cmap_names = [ 'nipy_spectral','viridis', 'plasma', 'inferno', 'magma', 'cividis',
                            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds','YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu','GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn',
                            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink','spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia','hot', 'afmhot', 'gist_heat', 'copper',
                            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu','RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic',
                            'twilight', 'twilight_shifted', 'hsv',
                            'Pastel1', 'Pastel2', 'Paired', 'Accent','Dark2', 'Set1', 'Set2', 'Set3','tab10', 'tab20', 'tab20b', 'tab20c',
                            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern','gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg','gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar'
                          ]

        self.sph_mode = True
        self.MESA_mode = False
        
        self.corner_message_text = tk.StringVar()
        self.corner_message_text.set("")
        self.corner_message_label = tk.Label(self.root,textvariable=self.corner_message_text)
        self.corner_message_label.place(rely=1.0,relx=1.0,x=0,y=0,anchor="se")
        
        self.right_frame = tk.Frame()
        self.left_frame = tk.Frame()
        
        self.graph_controls_frame = tk.Frame()
        self.graph_frame = tk.Frame(self.left_frame)
        self.graph_toolbar_frame = tk.Frame()
        self.axes_frame = tk.Frame(self.right_frame)
        self.files_frame = tk.Frame(self.right_frame)
        self.color_frame = tk.Frame(self.right_frame)
        

        # Setup the graph
        self.fig = Figure(figsize=(7,7),dpi=100)
        self.ax = self.fig.add_subplot(111)

        self.particles = []
        self.core_particles = []
        self.im = None
        
        self.canvas = FigureCanvasTkAgg(self.fig,master=self.graph_frame)

        self.canvas.get_tk_widget().grid(row=0,column=0)
        self.toolbar = CustomToolbar(self.canvas, self.graph_toolbar_frame)
        self.toolbar.update()

        self.x0 = tk.DoubleVar()
        self.y0 = tk.DoubleVar()
        self.w = tk.DoubleVar()
        self.h = tk.DoubleVar()
        self.x0.set(0.125)
        self.y0.set(0.125)
        self.w.set(0.7)
        self.h.set(0.825)
        self.ax.set_position([self.x0.get(),self.y0.get(),self.w.get(),self.h.get()])

        
        # Setup the color controls
        self.particle_color = tk.StringVar()
        self.particle_core_color = tk.StringVar()
        self.particle_color.set("#000000")
        self.particle_core_color.set("#000000")
        tk.Label(self.color_frame,text="Particles").grid(row=0,column=0,sticky='W')
        tk.Label(self.color_frame,text="Core particles").grid(row=1,column=0,sticky='W')
        self.particle_color_button = tk.Button(self.color_frame,command=self.choose_particle_color,height=1,width=2,padx=0,pady=0,bg=self.particle_color.get())
        self.particle_core_color_button = tk.Button(self.color_frame,command=self.choose_particle_core_color,height=1,width=2,padx=0,pady=0,bg=self.particle_core_color.get())
        self.particle_color_button.grid(row=0,column=1)
        self.particle_core_color_button.grid(row=1,column=1)

        self.cmap_idx = tk.StringVar()
        self.cmap_idx.set("0")
        self.cmap = tk.StringVar()
        self.cmap.set(self.cmap_names[int(self.cmap_idx.get())])
        self.cmap_idx.trace('w',self.update_cmap)
        tk.Label(self.color_frame,text="cmap").grid(row=0,column=2)
        self.cmap_entry = tk.Entry(self.color_frame,textvariable=self.cmap_idx,width=2)
        self.cmap_entry.grid(row=0,column=3)
        
        # Setup the axes prompt
        self.axish_var = tk.StringVar()
        self.axisv_var = tk.StringVar()
        self.axisc_var = tk.StringVar()
        self.axish_var.set(self.variables[0]) # x by default
        self.axisv_var.set(self.variables[1]) # y by default
        self.axisc_var.set(self.color_variables[0]) # Nothing by default

        self.axis_menu_width = tk.IntVar()
        self.axis_menu_width.set(20)

        self.axish_label = tk.Label(self.axes_frame,text="Horizontal Axis").grid(row=0,column=0,sticky='w')
        self.axisv_label = tk.Label(self.axes_frame,text="Vertical Axis").grid(row=1,column=0,sticky='w')
        self.axisc_label = tk.Label(self.axes_frame,text="Colorbar").grid(row=2,column=0,sticky='w')
        
        self.axish_menu = tk.OptionMenu(self.axes_frame,self.axish_var,*self.variables,command=self.draw_plot)
        self.axisv_menu = tk.OptionMenu(self.axes_frame,self.axisv_var,*self.variables,command=self.draw_plot)
        self.axisc_menu = tk.OptionMenu(self.axes_frame,self.axisc_var,*self.color_variables,command=self.draw_plot)
        self.axish_menu.config(width=self.axis_menu_width.get())
        self.axisv_menu.config(width=self.axis_menu_width.get())
        self.axisc_menu.config(width=self.axis_menu_width.get())
        self.axish_menu.grid(row=0,column=1)
        self.axisv_menu.grid(row=1,column=1)
        self.axisc_menu.grid(row=2,column=1)

        self.axish_islog = tk.IntVar()
        self.axisv_islog = tk.IntVar()
        self.axisc_islog = tk.IntVar()
        self.axish_is10 = tk.IntVar()
        self.axisv_is10 = tk.IntVar()
        self.axisc_is10 = tk.IntVar()
        self.axish_islog.set(0)
        self.axisv_islog.set(0)
        self.axisc_islog.set(0)
        self.axish_is10.set(0)
        self.axisv_is10.set(0)
        self.axisc_is10.set(0)
        
        smallframeh = tk.Frame(self.axes_frame)
        self.axish_log_button = tk.Checkbutton(smallframeh,command=self.draw_plot,variable=self.axish_islog)
        self.axish_10_button = tk.Checkbutton(smallframeh,command=self.draw_plot,variable=self.axish_is10)
        # Disable the buttons initially
        #self.axish_log_button.config(state='disabled')
        #self.axish_10_button.config(state='disabled')
        tk.Label(smallframeh,text="log").grid(row=0,column=1)
        tk.Label(smallframeh,text="10^").grid(row=1,column=1)
        self.axish_log_button.grid(row=0,column=0)
        self.axish_10_button.grid(row=1,column=0)

        smallframeh.grid(row=0,column=2)
        
        smallframev = tk.Frame(self.axes_frame)
        self.axisv_log_button = tk.Checkbutton(smallframev,command=self.draw_plot,variable=self.axisv_islog)
        self.axisv_10_button = tk.Checkbutton(smallframev,command=self.draw_plot,variable=self.axisv_is10)
        # Disable the buttons initially
        #self.axisv_log_button.config(state='disabled')
        #self.axisv_10_button.config(state='disabled')
        tk.Label(smallframev,text="log").grid(row=0,column=1)
        tk.Label(smallframev,text="10^").grid(row=1,column=1)
        self.axisv_log_button.grid(row=0,column=0)
        self.axisv_10_button.grid(row=1,column=0)

        smallframev.grid(row=1,column=2)
        
        smallframec = tk.Frame(self.axes_frame)
        self.axisc_log_button = tk.Checkbutton(smallframec,command=self.draw_plot,variable=self.axisc_islog)
        self.axisc_10_button = tk.Checkbutton(smallframec,command=self.draw_plot,variable=self.axisc_is10)
        # Disable the buttons initially
        #self.axisc_log_button.config(state='disabled')
        #self.axisc_10_button.config(state='disabled')
        tk.Label(smallframec,text="log").grid(row=0,column=1)
        tk.Label(smallframec,text="10^").grid(row=1,column=1)
        self.axisc_log_button.grid(row=0,column=0)
        self.axisc_10_button.grid(row=1,column=0)

        smallframec.grid(row=2,column=2)


        # Divide by 10 initially because full resolution takes a long time to compute
        fig_pix = np.asarray(self.fig.get_size_inches() * self.fig.dpi / 10.,dtype=int) # figure size in pixels
        
        smallframers = tk.Frame(self.axes_frame)
        self.resolution_scale_x = tk.IntVar()
        self.resolution_scale_y = tk.IntVar()
        self.resolution_scale_z = tk.IntVar()
        self.resolution_scale_x.set(fig_pix[0])
        self.resolution_scale_y.set(fig_pix[1])
        self.resolution_scale_z.set(min(fig_pix))

        smallerframers = tk.Frame(smallframers)
        
        tk.Label(smallerframers,text="Resolution (px)").grid(row=0,column=0)
        tk.Button(smallerframers,text="Draw",command=self.draw_plot,width=5,height=1,padx=0,pady=0).grid(row=0,column=1)

        smallerframers.grid(row=0,column=0,columnspan=6)
        
        self.resolution_scale_x_entry = tk.Entry(smallframers,textvariable=self.resolution_scale_x,width=4)
        self.resolution_scale_y_entry = tk.Entry(smallframers,textvariable=self.resolution_scale_y,width=4)
        self.resolution_scale_z_entry = tk.Entry(smallframers,textvariable=self.resolution_scale_z,width=4)
        self.resolution_scale_x_entry.grid(row=1,column=0)
        tk.Label(smallframers,text="x").grid(row=1,column=1)
        self.resolution_scale_y_entry.grid(row=1,column=2)
        tk.Label(smallframers,text="y").grid(row=1,column=3)
        self.resolution_scale_z_entry.grid(row=1,column=4)
        tk.Label(smallframers,text="z").grid(row=1,column=5)

        smallframers.grid(row=2,column=3)

        # Setup the files prompt
        self.files_var = tk.StringVar()
        if len(sys.argv) > 1:
            self.files_var.set(" ".join(sys.argv[1:]))

        self.files = sys.argv[1:]
        self.files_label = tk.Label(self.files_frame,text="File list").grid(row=0,column=0)
        self.files_text = tk.Entry(self.files_frame,textvariable=self.files_var,width=50)
        self.files_text.bind('<Return>',self.load_files)
        self.files_text.grid(row=0,column=1,padx=(0,3))
        tk.Button(self.files_frame,text="Load",command=self.load_files,width=5,height=1,padx=0,pady=0).grid(row=0,column=2)
        tk.Button(self.files_frame,text="Clear",command=self.clear_files,width=5,height=1,padx=0,pady=0).grid(row=0,column=3)
        self.current_file = tk.StringVar()
        self.current_file.set(self.files_var.get().split(" ")[0])
        self.current_file_idx = tk.IntVar()
        self.current_file_idx.set(0)

        

        # Setup the colorbar
        self.colorbar = None
        pos = self.ax.get_position()

        self.cax_xbuff = tk.DoubleVar()
        self.cax_width = tk.DoubleVar()
        self.cax_buff = tk.DoubleVar() # A "universal" buffer that helps make space for tick labels and the axis label
        self.cax_xbuff.set(0.01)
        self.cax_width.set(0.05)
        self.cax_buff.set(0.)
        self.cax = self.fig.add_axes([self.x0.get()+self.w.get()+self.cax_xbuff.get(),self.y0.get(),self.cax_width.get(),self.h.get()]) # Right side by default
        self.cax.xaxis.set_visible(False)
        self.cax.yaxis.tick_right()
        #self.cax.set_visible(False)

        self.hlabel_buff = tk.DoubleVar()
        self.vlabel_buff = tk.DoubleVar()
        self.hlabel_buff.set(0.1)
        self.vlabel_buff.set(0.1)
        self.hlabel = self.fig.text((pos.x1+pos.x0)/2.,pos.y0-self.hlabel_buff.get(),self.axish_var.get(),ha='center')
        self.vlabel = self.fig.text(pos.x0-self.vlabel_buff.get(),(pos.y1+pos.y0)/2.,self.axisv_var.get(),va='center',rotation='vertical')
        
        # Beneath the graph, give user some controls
        self.skip_magnitude = tk.IntVar()
        self.skip_magnitude.set(1)
        self.skip_magnitude_entry = tk.Entry(self.graph_controls_frame,textvariable=self.skip_magnitude,width=5)
        self.skip_magnitude_entry.grid(row=0,column=2)
        self.back_button = tk.Button(self.graph_controls_frame,command=self.previous_file,text="<<",width=2,height=1,padx=5,pady=5).grid(row=0,column=1)
        self.next_button = tk.Button(self.graph_controls_frame,command=self.next_file,text=">>",width=2,height=1,padx=5,pady=5).grid(row=0,column=3)
        self.current_file_label = tk.Label(self.graph_controls_frame,textvariable=self.current_file,padx=10).grid(row=0,column=0)
        
        
        # Draw the frames

        # Right side
        self.files_frame.grid(row=0,column=0)
        self.axes_frame.grid(row=1,column=0)
        self.color_frame.grid(row=2,column=0)

        # Left side
        self.graph_frame.grid(row=0,column=0)
        self.graph_controls_frame.grid(row=1,column=1,sticky='E')
        self.graph_toolbar_frame.grid(row=1,column=0,sticky='W')
        
        self.left_frame.grid(row=0,column=0,columnspan=2)
        self.right_frame.grid(row=0,column=2)


        # Draw the first file
        self.read_file()
        self.draw_plot()


    def update_cmap(self,*args):
        try:
            if int(self.cmap_idx.get()) in np.arange(len(self.cmap_names)):
                self.cmap.set(self.cmap_names[int(self.cmap_idx.get())])
        except ValueError:
            # The user did not use an integer value
            return

        self.im.set_cmap(self.cmap.get())

        self.canvas.draw()

        
    def draw_colorbar(self,*args):
        # Draw the colorbar relative to the axis
        
        if not self.cax.get_visible() and self.axisc_var.get() != "":
            self.cax.set_visible(True)
            # Adjust the size of the axis to accommodate the colorbar
            self.ax.set_position([self.x0.get(),self.y0.get(),self.w.get() - (self.cax_xbuff.get() + self.cax_width.get() + self.cax_buff.get()),self.h.get()])
            # Get the current axis position and draw the colorbar relative to it
            pos = self.ax.get_position()
            # For now, draw colorbar to the right side only
            self.cax.set_position([pos.x1 + self.cax_xbuff.get(),pos.y0,self.cax_width.get(),pos.height])

            if self.colorbar is None:
                self.colorbar = self.fig.colorbar(self.im,cax=self.cax)
        #print(self.colorbar)

    def hide_colorbar(self,*args):
        if self.cax.get_visible() and self.axisc_var.get() == "":
            #if self.colorbar is not None:
            #    self.colorbar.set_visible(False)
            self.cax.set_visible(False)
            self.ax.set_position([self.x0.get(),self.y0.get(),self.w.get() + (self.cax_xbuff.get() + self.cax_width.get() + self.cax_buff.get()), self.h.get()])

    def choose_particle_color(self,*args):
        self.particle_color.set(colorchooser.askcolor(parent=self.root,initialcolor=self.particle_color.get())[1])
        self.particle_color_button.config(bg=self.particle_color.get())

        for particles in self.particles:
            particles.set_color(self.particle_color.get())

        self.canvas.draw()
        
    def choose_particle_core_color(self,*args):
        self.particle_core_color.set(colorchooser.askcolor(parent=self.root,initialcolor=self.particle_core_color.get())[1])
        self.particle_core_color_button.config(bg=self.particle_core_color.get())

        for core_particles in self.core_particles:
            core_particles.set_color(self.particle_core_color.get())

        self.canvas.draw()


        
    def update_axis_labels(self,*args):
        if self.axish_islog.get() == 1 and self.axish_is10.get() == 0: # Only log10
            self.hlabel.set_text("log "+self.axish_var.get())
        elif self.axish_islog.get() == 0 and self.axish_is10.get() == 1: # Only 10^
            self.hlabel.set_text("10^ "+self.axish_var.get())
        elif self.axish_islog.get() == self.axish_is10.get(): # Both or neither
            self.hlabel.set_text(self.axish_var.get())

        if self.axisv_islog.get() == 1 and self.axisv_is10.get() == 0: # Only log10
            self.vlabel.set_text("log "+self.axisv_var.get())
        elif self.axisv_islog.get() == 0 and self.axisv_is10.get() == 1: # Only 10^
            self.vlabel.set_text("10^ "+self.axisv_var.get())
        elif self.axisv_islog.get() == self.axisv_is10.get(): # Both or neither
            self.vlabel.set_text(self.axisv_var.get())

        #self.hlabel = self.fig.text((pos.x1+pos.x0)/2.,0.01,self.axish_var.get(),ha='center')
        #self.vlabel = self.fig.text(0.01,(pos.y1+pos.y0)/2.,self.axisv_var.get(),va='center',rotation='vertical')
            
        # Reposition the labels
        #pos = self.ax.get_position()
        self.hlabel.set_position(((self.x0.get()+self.w.get()+self.x0.get())/2.,self.y0.get() - self.hlabel_buff.get()))
            
    def update_axes_menu(self,*args):
        # We have to completely re-make the optionmenu lists because tkinter sucks with these.
        self.axish_menu.destroy()
        self.axisv_menu.destroy()
        self.axisc_menu.destroy()
        self.axish_menu = tk.OptionMenu(self.axes_frame,self.axish_var,*self.variables,command=self.draw_plot)
        self.axisv_menu = tk.OptionMenu(self.axes_frame,self.axisv_var,*self.variables,command=self.draw_plot)
        self.axisc_menu = tk.OptionMenu(self.axes_frame,self.axisc_var,*self.color_variables,command=self.draw_plot)
        self.axish_menu.config(width=self.axis_menu_width.get())
        self.axisv_menu.config(width=self.axis_menu_width.get())
        self.axisc_menu.config(width=self.axis_menu_width.get())
        self.axish_menu.grid(row=0,column=1)
        self.axisv_menu.grid(row=1,column=1)
        self.axisc_menu.grid(row=2,column=1)
        
        
       
        
    def load_files(self,*args):
        self.files = []
        for f in self.files_var.get().split(" "):
            if "*" in f:
                self.files.extend(sorted(glob(f)))
            else:
                self.files.extend(glob(f))
                
        self.draw_plot()
        self.corner_message_text.set("File list loaded")
        self.corner_message_label.update_idletasks()

            
    def clear_files(self,*args):
        self.files = []
        self.files_var.set("")

    def read_file(self,*args):
        # Start the "Loading..." message when we start to read the data, and get rid of the message
        # after we have plotted the data (in draw_plot())
        self.corner_message_text.set("Loading...")
        self.corner_message_label.update_idletasks()
        self.data, self.header = read_sph(self.current_file.get())

        if self.data is not None and self.header is not None:
            # This is an SPH file
            self.variables = [ "x",
                               "y",
                               "z",
                               "m",
                               "h",
                               "rho",
                               "vx",
                               "vy",
                               "vz",
                               "vxdot",
                               "vydot",
                               "vzdot",
                               "u",
                               "udot",
                               "grpot",
                               "meanmolecular",
                               "cc",
                               "divv",
                             ]
            self.color_variables = [ "",
                                     "column density",
                                   ]
            self.sph_mode = True
            self.MESA_mode = False
        else:
            # This is some other file

            # Check if it is a mesa file
            header_attr, cols, data = read_mesa(self.current_file.get())
            if header_attr is not None and cols is not None and data is not None:
                keys = np.asarray(list(cols.items()))[:,0]
                values = np.asarray(list(cols.items()))[:,1].astype(int)
                self.variables = np.insert(keys[np.argsort(values)],0,"")
                self.color_variables = [ "" ] # No colorbars for MESA files
                self.data = data
                self.MESA_mode = True
                self.sph_mode = False
            else:                
                # Unrecognized file format
                self.corner_message_text.set("Unrecognized file type '"+self.current_file.get()+"'")
                self.corner_message_label.update_idletasks()
        
                # Disable the menu buttons
                self.axish_menu.config(state='disabled')
                self.axisv_menu.config(state='disabled')

                self.sph_mode = False
                self.MESA_mode = False
                
                return False
        

        self.axish_menu.config(state='normal')
        self.axisv_menu.config(state='normal')
        
        self.update_axes_menu()
        
        return True
            
    def init_kernels(self,*args):
        # Compute kernel tables
        def w(u):
            # Inspired by StarSmasher. This is a cubic spline kernel
            result = np.zeros(len(u))
            idx1 = u < 0
            idx2 = np.logical_and(u >= 0,u < 1)
            idx3 = np.logical_and(u >= 1, u < 2)

            result[idx1] = 1.
            result[idx2] = 1.+u[idx2]**2.*(-1.5+0.75*u[idx2])
            result[idx3] = 0.25*(2.-u[idx3])**3.
            
            result=result/np.pi

            return result
        
        
        u2 = 4.*np.arange(self.ntab-1) / float(self.ntab - 1)
        self.wtab = w(np.sqrt(u2))
        
        
    def plot_column_density(self,x,y,z,m,hp,*args):
        #from scipy.spatial.distance import cdist
        #from scipy.integrate import simps
        # Plot data with a colorbar
        
        # First, figure out how many pixels are on the screen
        #dimens = np.asarray(self.fig.get_size_inches() * self.fig.dpi,dtype=int) # in pixels
        #dimens = dimens/10.
        #xpix = int(dimens[0])
        #ypix = int(dimens[1])
        #zpix = min(xpix,ypix)
        #zpix = 10
        xpix = self.resolution_scale_x.get()
        ypix = self.resolution_scale_y.get()
        zpix = self.resolution_scale_z.get()

        # Gather necessary particle data
        #x = data[:,0]
        #y = data[:,1]
        #z = data[:,2]
        #hp = data[:,4]
        hp2 = np.multiply(hp,2.)
        
        # Determine the physical bounds of the grid
        #xlim = self.ax.get_xlim()
        #ylim = self.ax.get_ylim()
        #xmin = xlim[0]
        #xmax = xlim[1]
        #ymin = ylim[0]
        #ymax = ylim[1]
        xmin = np.amin(x-hp2)
        xmax = np.amax(x+hp2)
        ymin = np.amin(y-hp2)
        ymax = np.amax(y+hp2)
        zmin = np.amin(z-hp2)
        zmax = np.amax(z+hp2)

        xpos = np.linspace(xmin,xmax,xpix)
        ypos = np.linspace(ymin,ymax,ypix)
        zpos = np.linspace(zmin,zmax,zpix)

        nproc = mp.cpu_count()

        # We assume the image will never be too small (# x pixels < # processes)
        # Split the # of pixels in the x direction across all processes
        xpos_proc = np.array_split(xpos,nproc)

        # Keep track of the xpos indices
        xpos_idx_proc = np.array_split(np.arange(len(xpos),dtype=int),nproc)

        self.corner_message_text.set("Calculating column density...")
        self.corner_message_label.update_idletasks()
        
        start = time.time()
        q = mp.Queue()
        process = [None]*nproc
        for n in range(0,nproc):
            process[n] = mp.Process(target=self.calculate_coldens, args=(q, n, x,y,z,m,hp, xpos_idx_proc[n], xpos_proc[n], ypos, zpos))
            process[n].start()

        xpos_idx_proc_calculated = [None]*nproc
        grids = [None]*nproc
        for n in range(0,nproc):
            res = q.get()
            xpos_idx_proc_calculated[n] = res[0]
            grids[n] = res[1]
            
        for proc in process:
            proc.join()

        grid = np.zeros((xpix,ypix))
        for n in range(0,nproc):
            grid_proc = grids[n]
            grid[xpos_idx_proc_calculated[n]] = grid_proc

        if self.axisc_islog.get() == 1:
            grid = np.log10(grid)

        print(time.time()-start)
        self.im = self.ax.imshow(grid,extent=(xmin,xmax,ymin,ymax),cmap=self.cmap.get())
        self.corner_message_text.set("")

    def calculate_coldens(self,queue,n,x,y,z,m,hp,xpos_idx_proc,xpos,ypos,zpos,*args):
        # Calculate the column density for this LOS (xpos,ypos)
        # Points along the LOS, zpos, are given and calculated outside this function
        # Returns an array of shape (len(xpos), len(ypos)). Each element of the
        # array is the column density at that (xpos, ypos).

        from scipy.spatial.distance import cdist
        from scipy.integrate import simps

        #xy = data[:,0:2]
        #xyz = data[:,0:3]
        xy = np.column_stack((x,y))
        xyz = np.column_stack((x,y,z))
        #z = data[:,2]
        #m = data[:,3]
        #hp = data[:,4]
        hp2 = np.multiply(hp,2.)
        hp22 = np.power(hp2,2.)
        hp2p = np.power(hp,2.)
        hp3p = np.power(hp,3.)

        xpix = len(xpos)
        ypix = len(ypos)
        zpix = len(zpos)

        xypos = np.zeros((xpix*ypix,2))
        xypos[:,0] = np.repeat(xpos,ypix)
        xypos[:,1] = np.tile(ypos,xpix)

        xyzpos = np.zeros((xpix*ypix*zpix,3))
        xyzpos[:,0] = np.repeat(xpos,ypix*zpix)
        xyzpos[:,1] = np.tile(np.repeat(ypos,zpix),xpix)
        xyzpos[:,2] = np.tile(zpos,xpix*ypix)


        #dr = cdist(xyzpos,xyz)
        
        
        drp_arr2 = cdist(xypos,xy,'sqeuclidean')
        
        thisgrid = np.zeros((len(xpos),len(ypos)))
        
        for i in range(0,len(xpos)):
            for j in range(0,len(ypos)):
                drp2 = drp_arr2[i*ypix + j]
                idx_xy = drp2 < hp22
                if not np.any(idx_xy): continue

                dens = np.zeros(len(zpos))
                for k in range(0,len(zpos)):
                    # Calculate the distance of this (xpos,ypos,zpos) to the particles on the LOS (idx)
                    
                    dr2 = drp2[idx_xy] + (zpos[k] - z[idx_xy])**2.
                    idx = dr2 < hp22[idx_xy]
                    if not np.any(idx): continue
                    indices = (self.ctab * dr2[idx]/hp2p[idx_xy][idx]).astype(np.int,copy=False)
                    wpc = self.wtab[indices] / hp3p[idx_xy][idx]
                    dens[k] = np.sum(m[idx_xy][idx] * wpc)
                thisgrid[i][j] = simps(dens,x=zpos)
                
        queue.put([xpos_idx_proc,thisgrid])

    
        
        
        
        
    def plot_particles(self,x,y,*args):    
        if self.sph_mode and not self.MESA_mode: # If we are in SPH mode,
            self.particles.append(self.ax.scatter(x,y,s=1,marker='.',color=self.particle_color.get()))
            core_idx = np.where(self.data[:,12] == 0)[0] # True only in StarSmasher
            if len(core_idx) > 0:
                self.core_particles.append(self.ax.scatter(x[core_idx],y[core_idx],s=1,marker='.',color=self.particle_core_color.get()))
        elif not self.sph_mode and self.MESA_mode: # If we are in MESA mode
            self.particles.append(self.ax.scatter(x,y,s=1,marker='.',color=self.particle_color.get()))
            
        
    def update_log_10_buttons(self,*args):
        xidx = [i for i in range(0,len(self.variables)) if self.variables[i] == self.axish_var.get()]
        yidx = [i for i in range(0,len(self.variables)) if self.variables[i] == self.axisv_var.get()]
        cidx = [i for i in range(0,len(self.color_variables)) if self.color_variables[i] == self.axisc_var.get()]
        
        if type(xidx).__name__ == 'list': xidx = xidx[0]
        if type(yidx).__name__ == 'list': yidx = yidx[0]
        if type(cidx).__name__ == 'list': cidx = cidx[0]

        x = self.data[:,xidx]
        y = self.data[:,yidx]

        if np.all(x > 0):
            # The horizontal axis is able to be in log space
            self.axish_log_button.config(state='normal')
        else:
            self.axish_islog.set(0)
            self.axish_log_button.config(state='disabled')
 
        if np.all(y > 0):
            # The vertical axis is able to be in log space
            self.axisv_log_button.config(state='normal')
        else:
            self.axisv_islog.set(0)
            self.axisv_log_button.config(state='disabled')


    def clear_plot(self,*args):
        for particles in self.particles:
            particles.remove()
            self.particles.remove(particles)
        for core_particles in self.core_particles:
            core_particles.remove()
            self.core_particles.remove(core_particles)
        if self.im is not None:
            self.im.set_visible(False)

    def draw_plot(self,*args):
        # For now, return if there is no data to plot
        if self.data is None:
            print("No data to plot")
            return
        
        # Update the data in the plot
        self.clear_plot()

        self.update_log_10_buttons()

        xidx = [i for i in range(0,len(self.variables)) if self.variables[i] == self.axish_var.get()]
        yidx = [i for i in range(0,len(self.variables)) if self.variables[i] == self.axisv_var.get()]
        cidx = [i for i in range(0,len(self.color_variables)) if self.color_variables[i] == self.axisc_var.get()]
        
        if type(xidx).__name__ == 'list': xidx = xidx[0]
        if type(yidx).__name__ == 'list': yidx = yidx[0]
        if type(cidx).__name__ == 'list': cidx = cidx[0]

        x = self.data[:,xidx]
        y = self.data[:,yidx]
        
        if self.axish_islog.get() == 1:
            x = np.log10(x)
        if self.axisv_islog.get() == 1:
            y = np.log10(y)
        if self.axish_is10.get() == 1:
            x = 10.**x
        if self.axisv_is10.get() == 1:
            y = 10.**y

        
        # Don't worry about aspect ratios yet, this stuff is a bit complicated.
        #if len([i for i in ["x","y","z"] if i == self.axish_var.get() or i == self.axisv_var.get()]) >= 2:
        #    self.ax.set_aspect('equal')
        #else:
        #    self.ax.set_aspect('auto')


        if self.axisc_var.get() == "":
            self.plot_particles(x,y)

            # Need to manually scale the axis because .relim() is not yet supported for scatter plots
            margin = self.ax.margins()
            xmin = np.amin(x)
            xmax = np.amax(x)
            ymin = np.amin(y)
            ymax = np.amax(y)
            dx = xmax-xmin
            dy = ymax-ymin
            self.ax.set_xlim(xmin - dx*margin[0], xmax + dx*margin[0])
            self.ax.set_ylim(ymin - dy*margin[1], ymax + dy*margin[1])
            self.hide_colorbar()
            
        elif self.axisc_var.get() == "column density":
            # Figure out the z axis from the given x and y axes
            zidx = list(set([0,1,2]).difference(set([xidx,yidx])))[0]
            self.plot_column_density(x,y,self.data[:,zidx],self.data[:,3],self.data[:,4])
            self.im.set_visible(True)
            self.draw_colorbar()
            self.ax.relim()

        self.update_axis_labels()
        self.canvas.draw()
        self.corner_message_text.set("")
        
    def next_file(self,*args):
        nxt_idx = self.current_file_idx.get() + self.skip_magnitude.get()
        if nxt_idx >= len(self.files)-1:
            # Reached end of file list
            if self.current_file_idx.get() != len(self.files)-1:
                self.current_file_idx.set(len(self.files)-1)
                self.current_file.set(self.files[-1])
                isread = self.read_file()
                if isread: self.draw_plot()

            self.corner_message_text.set("End of file list")
            self.corner_message_label.update_idletasks()
            self.skip_magnitude_entry.delete(0,'end')
            self.skip_magnitude_entry.insert(0,'1')
            self.skip_magnitude.set(1)
                
            return

        self.current_file_idx.set(nxt_idx)
        self.current_file.set(self.files[self.current_file_idx.get()])
        isread = self.read_file()
        if isread: self.draw_plot()
        
        

    def previous_file(self,*args):
        prev_idx = self.current_file_idx.get() - self.skip_magnitude.get()
        if prev_idx <= 0:
            # Reached beginning of file list
            if self.current_file_idx.get() != 0:
                self.current_file_idx.set(0)
                self.current_file.set(self.files[0])
                isread = self.read_file()
                if isread: self.draw_plot()
                
            self.corner_message_text.set("Start of file list")
            self.corner_message_label.update_idletasks()
            self.skip_magnitude_entry.delete(0,'end')
            self.skip_magnitude_entry.insert(0,'1')
            self.skip_magnitude.set(1)
            
            return

        self.current_file_idx.set(prev_idx)
        self.current_file.set(self.files[self.current_file_idx.get()])
        isread = self.read_file()
        if isread: self.draw_plot()




if __name__ == '__main__':
    root = tk.Tk()
    root.wm_title("PySplash")
    main(root)
    root.mainloop()
